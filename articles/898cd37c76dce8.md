---
title: "Rust ç«¶ãƒ—ãƒ­ ãƒãƒ¼ãƒˆã‚·ãƒ¼ãƒˆé›†"
emoji: ğŸƒ
type: "tech"
topics: ["rust", "AtCoder", "ç«¶ãƒ—ãƒ­"]
published: true
---

Rustã§ç«¶ãƒ—ãƒ­ã—ã¦ã„ã‚‹ã¨ãã«ã€ã“ã‚Œã‚„ã‚ŠãŸã„ã¨ãã©ã†ã‚„ã‚‹ã ã£ã‘??ã¨ãªã‚ŠãŒã¡ãªã®ã§ã€ãƒãƒ¼ãƒˆã‚·ãƒ¼ãƒˆã‚’ä½œã‚Šã¾ã—ãŸã€‚
é©å®œæ›´æ–°ãƒ»ä¿®æ­£ã—ã¾ã™ã€‚
AtCoderã«ãŠã‘ã‚‹å…¥å‡ºåŠ›æ–¹æ³•ã¯ä»¥ä¸‹ã®è¨˜äº‹ã‚’å‚ç…§ã«ã—ã¦ãã ã•ã„ã€‚

https://zenn.dev/tipstar0125/articles/f9c4626cdd4d5b

# Vec

### iter

#### - enumerate

forã§é…åˆ—ã‚’indexã¨ä¸€ç·’ã«å›ã™ã€‚

```rust
let A = vec![3, 4, 5];
for (i, &a) in A.iter().enumerate() {
    println!("{} {}", i, a);
}
// 0 3
// 1 4
// 2 5
```

#### - rev

forã§é€†å›ã—

```rust
let N = 3;
for i in (0..N).rev() {
    println!("{} ", i);
}
// 2 1 0
let A = vec![3, 4, 5];
for &a in A.iter().rev() {
    println!("{} ", a);
}
// 5 4 3
```

#### - enumerate + rev

```rust
let A = vec![3, 5, 2, 1, 4];
for (i, &a) in A.iter().enumerate().rev() {
    println!("{} {}", i, a);
}
// 4 4
// 3 1
// 2 2
// 1 5
// 0 3
```

```rust
let A = vec![3, 5, 2, 1, 4];
for (i, &a) in A.iter().rev().enumerate() {
    println!("{} {}", i, a);
}
// 0 4
// 1 1
// 2 2
// 3 5
// 4 3
```


#### - join

é…åˆ—ã‚’æŒ‡å®šæ–‡å­—åŒºåˆ‡ã‚Šã§å‡ºåŠ›ã™ã‚‹ã€‚

```rust
A.iter().join(" ");  // ã‚¹ãƒšãƒ¼ã‚¹åŒºåˆ‡ã‚Š
A.iter().join("\n");  // æ”¹è¡ŒåŒºåˆ‡ã‚Š
```

#### - permutations

é †åˆ—å…¨æ¢ç´¢

```rust
let n = 3;
for p in (0..n).permutations(n) {
    println!("{:?}", p);
}
// [0, 1, 2]
// [0, 2, 1]
// [1, 0, 2]
// [1, 2, 0]
// [2, 0, 1]
// [2, 1, 0]

// ä»¥ä¸‹ã§ã‚‚OK
let vec = vec![0, 1, 2];
for p in vec.iter().permutations(vec.len()) {
    println!("{:?}", p);
}
```

`next_permutation`ã‚„`prev_permutation`ã‚‚ã‚ã‚‹ã€‚

```rust
let mut vec = vec![0, 1, 2];
vec.next_permutation();
println!("{:?}", vec);  // [0, 2, 1]
vec.prev_permutation();
println!("{:?}", vec);  // [0, 1, 2]
```

#### - combinations

çµ„åˆã›ã®å…¨ãƒ‘ã‚¿ãƒ¼ãƒ³ã‚’åˆ—æŒ™

```rust
for c in (0..3).combinations(2) {
    println!("{:?}", c);
}
// [0, 1]
// [0, 2]
// [1, 2]
let vec = vec![1, 2, 3, 3];
for c in vec.iter().combinations(2) {
    println!("{:?}", c);
}
// [1, 2]
// [1, 3]
// [1, 3]
// [2, 3]
// [2, 3]
// [3, 3]
```

ä»¥ä¸‹ã®ã‚ˆã†ã«ã™ã‚‹ã¨bitå…¨æ¢ç´¢ã¨åŒã˜ã“ã¨ãŒã§ãã‚‹ã€‚

```rust
let n = 3;
for i in 1..=n {
    for c in (0..n).combinations(i) {
        println!("{:?}", c);
    }
}
// [0]
// [1]
// [2]
// [0, 1]
// [0, 2]
// [1, 2]
// [0, 1, 2]
```

### ã‚½ãƒ¼ãƒˆ

- æ˜‡é †ã€é™é †

```rust
let mut A = vec![3, 1, 2];
A.sort(); // æ˜‡é †
A.reverse();  // é™é †
A.sort_by(|a, b| a.cmp(b)); // æ˜‡é †
A.sort_by(|a, b| b.cmp(a)); // é™é †
```

- ã‚­ãƒ¼ã‚’æŒ‡å®šã—ã¦ã‚½ãƒ¼ãƒˆ

```rust
let mut A = vec![(1, 3), (2, 1), (3, 2)];
A.sort_by(|(_, a), (_, b)| b.cmp(a)); // ç¬¬2è¦ç´ ã§é™é †

let mut B = vec![("a", 90, 80), ("d", 70, 80), ("c", 90, 60), ("b", 70, 80)];
B.sort_by(|(a0, a1, a2), (b0, b1, b2)| (-a1, a2, a0).cmp(&(-b1, b2, b0)));
// ç¬¬2è¦ç´ ã§é™é †ã€ç¬¬3è¦ç´ ã§æ˜‡é †ã€ç¬¬1è¦ç´ ã§æ˜‡é †ã®å„ªå…ˆåº¦ã§ä¸¦ã³æ›¿ãˆ
// [("c", 90, 60), ("a", 90, 80), ("b", 70, 80), ("d", 70, 80)]

// ãƒã‚¤ãƒŠã‚¹ã‚’ä½¿ç”¨ã™ã‚‹ã¨ã€å‹ã‚’isizeã«ã™ã‚‹å¿…è¦ãŒã‚ã‚‹ãŒã€
// ä»¥ä¸‹ã®ã‚ˆã†ã«Reverseã‚’ä½¿ç”¨ã™ã‚‹ã“ã¨ã§usizeã®ã¾ã¾é™é †ã«ã§ãã‚‹ã€‚
use std::cmp::Reverse;
B.sort_by(|(a0, a1, a2), (b0, b1, b2)| (Reverse(a1), a2, a0).cmp(&(Reverse(b1), b2, b0)));
```

- é‡è¤‡å‰Šé™¤

`Vec`ã®é‡è¤‡ã‚’å‰Šé™¤ã™ã‚‹ã¨ãã¯äº‹å‰ã«ã‚½ãƒ¼ãƒˆã™ã‚‹ã€‚
ã‚½ãƒ¼ãƒˆã—ãªã„ã¨ã€å‰Šé™¤ã•ã‚Œãªã„ã€‚ã€‚ã€‚

```rust
let mut A = vec![3, 1, 2];
A.sort();
A.dedup();
```

### Vecã®å¤‰æ›

```rust
use std::collections::VecDeque;
let mut A: VecDeque<_> = A.iter().cloned().collect();
let mut set: BTreeSet<_> = A.iter().cloned().collect();
```

# æ–‡å­—åˆ—

### chars

`String`ã‚’1æ–‡å­—ãšã¤å‡¦ç†ã™ã‚‹ã«ã¯ã€`chars()`ã‚’ä½¿ç”¨ã™ã‚‹ã€‚

```rust
let S = "abc".to_string();
for c in S.chars() {
    print!("{} ", c);  // a b c
}
```

### æ–‡å­—åè»¢

```rust
let S = "abc".to_string();
let S_rev = S.chars().rev().collect::<String>();
println!("{}", S_rev);  // cba
```

### ã‚¹ãƒ©ã‚¤ã‚¹

```rust
let S = "abc".to_string();
println!("{}", &S[1..]);  // bc
println!("{}", &S[..2]);  // ab
```

### æ–‡å­—ã‚’abc...ã®é †ã«æ•°å€¤ã«å¤‰æ›

```rust
let s = 'a';
println!("{}", s as u8 - b'a' + 1);  // 1
let s = 'B';
println!("{}", s as u8 - b'A' + 1);  // 2, 2023/02/14 modified
```

# BTreeSet/BTreeMap

åŒã˜ã‚ˆã†ãªã“ã¨ãŒã§ãã‚‹`HashSet`ã¨`HashMap`ãŒã‚ã‚‹ãŒã€ãƒ‡ãƒãƒƒã‚°ã™ã‚‹ã¨ãã«ã€æ˜‡é †ã«ä¸¦ã‚“ã§ã„ãŸæ–¹ãŒåˆ†ã‹ã‚Šã‚„ã™ã„ã€äºŒåˆ†æ¢ç´¢ãŒã§ãã‚‹ã€ã¨ã„ã†ãƒ¡ãƒªãƒƒãƒˆãŒã‚ã‚‹ã®ã§ã€`BTreeSet`ã¨`BTreeMap`ã‚’ä½¿ç”¨ã™ã‚‹ã€‚

### BTreeMapã®åˆæœŸåŒ–
åˆæœŸåŒ–ã®éš›ã€å‹ã‚’å®šç¾©ã—ãªãã¦ã‚‚ã€é¡æ¨ã—ã¦ãã‚Œã‚‹ãŒã€Pythonã§ã„ã†`defaultdict`ã®ã‚ˆã†ãªä½¿ã„æ–¹ã‚’ã™ã‚‹ãŸã‚ã«ã€å‹å®šç¾©ã™ã‚‹ã€‚

```rust
let mut map: BTreeMap<usize, usize> = BTreeMap::new();
for &a in &A {
    *map.entry(a).or_default() += 1;  // ãƒ‡ãƒªãƒ•ã‚¡ãƒ¬ãƒ³ã‚¹ãŒå¿…è¦, åˆæœŸå€¤ï¼š0
}
```

```rust
let mut map: BTreeMap<usize, Vec<usize>> = BTreeMap::new();
for (i, &a) in A.iter().enumerate() {
    map.entry(a).or_default().push(i + 1);  // åˆæœŸå€¤ï¼šç©ºé…åˆ—
}
```

### ãƒªã‚»ãƒƒãƒˆ
`BTreeSet`ã‚„`BTreeMap`ã‚’ç©ºã«ã™ã‚‹ã«ã¯`clear()`ã‚’ä½¿ç”¨ã™ã‚‹ã€‚

```rust
set.clear();
map.clear();
```

### äºŒåˆ†æ¢ç´¢

`HashSet`ã§ã¯`lower_bound`ãŒä½¿ç”¨ã§ããªã„ã€‚ä»£ã‚ã‚Šã«`BTreeSet`ã®`range`ã‚’ä½¿ç”¨ã™ã‚‹ã€‚ä»¥ä¸‹ã¯`BTreeSet`ã®ä¾‹ã ãŒã€`BTreeMap`ã®ã‚­ãƒ¼ã§ã‚‚åŒã˜ã“ã¨ãŒã§ãã‚‹ã€‚

```rust
let mut set = BTreeSet::new();
let value = set.range(x..).next().unwrap(); // lower_boundç›¸å½“
let value = set.range(..x).next_back().unwrap();  // xã‚ˆã‚Šå°ã•ã„è¦ç´ ã®ä¸­ã§æœ€å¤§ã®è¦ç´ 
let value = set.range(x..=y);  // xä»¥ä¸Šyä»¥ä¸‹
```

### é›†åˆã®è¨ˆç®—

è¨ˆç®—å¾Œã®å‹ãŒå¤‰ã‚ã‚‰ãšã€ä½¿ã„ã¾ã‚ã›ã‚‹ä»¥ä¸‹ã‚’ä½¿ç”¨ã™ã‚‹ã€‚

```rust
let mut set = BTreeSet::new();
let mut set1 = BTreeSet::new();
set1.insert(1);
set1.insert(2);
set1.insert(3);
let mut set2 = BTreeSet::new();
set2.insert(1);
set2.insert(2);
set2.insert(4);
set = &set1 | &set2;  // å’Œ
println!("{:?}", set);  // {1, 2, 3, 4}
set = &set1 - &set2;  // å·®
println!("{:?}", set);  // {3}
set = &set1 & &set2;  // ç©
println!("{:?}", set);  // {1, 2}
set = &set1 ^ &set2;  // å¯¾ç§°å·®
println!("{:?}", set);  // {3, 4}
```

ä»¥ä¸‹ã¯è¨ˆç®—å¾Œã®å‹ãŒ`HashSet`ã‚„`BTreeSet`ã§ã¯ãªãã€`Union`ã¨ã‹ã«ãªã‚‹ã®ã§ã€ä½¿ã„é“ãªã•ãã†??
è¨ˆç®—çµæœã‚’ä½¿ã„ã¾ã‚ã—ãŸã„å ´åˆã«éƒ½åˆãŒæ‚ªã„ã€‚`into_iter().copied().collect()`ã§å¤‰æ›ã§ãã‚‹ã‘ã©ã€é¢å€’ã€‚

```rust
a.union(&b)  // å’Œ
a.difference(&b)  // å·®
a.intersection(&b)  // ç©
a.symmetric_difference(&b)  // å¯¾ç§°å·®
```

# ã‚°ãƒ©ãƒ•

### ã‚°ãƒ©ãƒ•ã®é ‚ç‚¹ãŒæ–‡å­—åˆ—ã‚„å¤§ããªæ•°å€¤ã®ã¨ãã®å¤‰æ›

ã‚°ãƒ©ãƒ•ã®é ‚ç‚¹ãŒæ–‡å­—åˆ—ã‚„å¤§ããªæ•°å€¤ã®ã¨ãã¯ã€éš£æ¥ãƒªã‚¹ãƒˆã‚’é…åˆ—ã§ã¯ãªãã€`HashMap`ã§ä½œã‚‹ã“ã¨ã§å‡¦ç†ã§ãã‚‹ãŒã€ä»¥ä¸‹ã®ã‚ˆã†ã«å¤‰æ›ã™ã‚‹`HashMap`ã‚’ã¤ãã‚Šã€éš£æ¥ãƒªã‚¹ãƒˆã‚’é…åˆ—ã§ä½œã‚‹ã“ã¨ãŒã§ãã‚‹ã€‚ã‚­ãƒ¼ã¯ãƒ¦ãƒ‹ãƒ¼ã‚¯ãªã®ã§ã€åŒã˜ã‚­ãƒ¼ã®ã‚‚ã®ã¯å‰Šé™¤ã•ã‚Œã‚‹ã€‚

```rust
let mut x = vec![];
for (s, t) in &ST {
    x.push(s.as_str());
    x.push(t.as_str());
}

let map: BTreeMap<_, _> = x.iter().enumerate().map(|(i, &s)| (s, i)).collect();
```


# åµŒã‚ŠãŒã¡ãªã‚¨ãƒ©ãƒ¼

- subtract with overflow

å‹ãŒ`usize`ã®ã¨ãã€å¼•ãç®—ã‚’ä½¿ç”¨ã—ãŸçµæœã€è² ã®å€¤ã«ãªã‚‹ã¨ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã™ã‚‹ã€‚`isize`ã‚’ä½¿ç”¨ã™ã‚‹ã‹ã€ç§»é …ã—ã¦å¼•ãç®—ã‚’ä½¿ç”¨ã—ãªã„ã‚ˆã†ã«å·¥å¤«ã™ã‚‹å¿…è¦ãŒã‚ã‚‹ã€‚

```rust
input! {
    N: usize,
    A: [usize; N]
}

for i in 0..N {
    // è² ã®å€¤ã«ãªã‚‹ã‚ˆã†ãªè¨ˆç®—ã‚’ã•ã›ãªã„
    if a - b > 0 {} // NG
    if a > b {} // OK
    
    // è² ã«ãªã‚‰ãªã„ã“ã¨ã‚’ç¢ºèªã—ã¦ã‹ã‚‰indexæŒ‡å®šã™ã‚‹
    if A[a-b] > c {}  //NG
    if a > b && A[a-b] > c {}  //OK
    
    // é…åˆ—ã®indexã‚’æŒ‡å®šã™ã‚‹å¤‰æ•°ã®å‹ãŒisizeã®å ´åˆã¯ã€asã§usizeã«å¤‰æ›´
    A[d as usize]
}

```

- å‹æ¨è«–ã§ã€å‹ãŒi32ã¨ã‹ã«ãªã‚‹å ´åˆã€ã‚ªãƒ¼ãƒãƒ¼ãƒ•ãƒ­ãƒ¼ã«ã‚ˆã‚Šã€WAã«ãªã‚‹ã®ã§ã€å‹ã‚’æŒ‡å®š

i32ãŒæ‰±ãˆã‚‹æ•°ã®ä¸Šé™ã‚’è¶…ãˆã¦ã—ã¾ã†å ´åˆã€ã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ ã¯æ­£ã—ãã§ã‚‚WAã«ãªã£ã¦ã—ã¾ã„ã€ä½•ãŒåŸå› ã§WAãŒå‡ºã¦ã„ã‚‹ã®ã‹åˆ†ã‹ã‚‰ãªããªã‚‹ã®ã‚’é˜²ããŸã‚ã«ã€æ„è­˜ã—ã¦ãŠã„ãŸæ–¹ãŒè‰¯ã„ã€‚ã¾ãŸã€ãªãœWAã«ãªã£ãŸã®ã‹åŸå› ä¸æ˜ãªå ´åˆã¯ã€å¤‰æ•°ã«ãƒ›ãƒãƒ¼ã—ã¦ã€æ„å›³ã—ã¦ã„ãªã„å‹ã«ãªã£ã¦ã„ãªã„ã‹ç¢ºèªã™ã‚‹ã€‚

```rust
// ã“ã‚Œã ã‘ã ã¨å‹æ¨è«–ã§i32ã«ãªã‚‹å ´åˆãŒã‚ã‚‹
let mut ans = 0; // NG(å³å¯†ã«ã¯ã“ã‚Œã§å•é¡Œãªã„å ´åˆã‚‚ã‚ã‚‹)
let mut ans: usize = 0; // OK
let mut ans = 0_usize; // OK
```

# ãã®ä»–

### ã‚¿ãƒ—ãƒ«åˆ†å‰²ä»£å…¥

```rust 
input! {
    N: usize,
    LR: [(usize, usize); N]
}

for i in 0..N {
    let l = LR[i].0;
    let r = LR[i].1;
    // ä¸Šè¿°ã§ã‚‚è‰¯ã„ãŒã€ä»¥ä¸‹ã®ã‚ˆã†ã«åˆ†å‰²ä»£å…¥å¯èƒ½
    let (l, r) = LR[i];
    let (mut l, mut r) = LR[i]; // å€¤ã‚’å¤‰æ›´ã™ã‚‹å ´åˆ
}
```

### ãƒ‘ã‚¿ãƒ¼ãƒ³ãƒãƒƒãƒ

```rust
// queryã®ç¬¬ä¸€è¦ç´ ã§ã‚¯ã‚¨ãƒªã®ãƒ‘ã‚¿ãƒ¼ãƒ³(1 or 2 or 3)ã‚’æŒ‡å®šã—ã€ãã®ä»–ã®è¦ç´ ï¼ˆå¼•æ•°ï¼‰ã§å‡¦ç†
for &q in &query {
    match q {
        (1, x, y) => {
            // something
        }
        (2, _, _) => {
            // something
        }
        (3, x, _) => {
            // something
        }
        (_, _, _) => unreachable!(),
    }
}
```