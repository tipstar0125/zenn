---
title: "Rust ç«¶ãƒ—ãƒ­ ãƒãƒ¼ãƒˆã‚·ãƒ¼ãƒˆé›†"
emoji: ğŸƒ
type: "tech"
topics: ["rust", "AtCoder", "ç«¶ãƒ—ãƒ­"]
published: true
---

Rustã§ç«¶ãƒ—ãƒ­ã—ã¦ã„ã‚‹ã¨ãã«ã€ã“ã‚Œã‚„ã‚ŠãŸã„ã¨ãã©ã†ã‚„ã‚‹ã ã£ã‘??ã¨ãªã‚ŠãŒã¡ãªã®ã§ã€ãƒãƒ¼ãƒˆã‚·ãƒ¼ãƒˆã‚’ä½œã‚Šã¾ã—ãŸã€‚
é©å®œæ›´æ–°ãƒ»ä¿®æ­£ã—ã¾ã™ã€‚
AtCoderã«ãŠã‘ã‚‹å…¥å‡ºåŠ›æ–¹æ³•ã¯ä»¥ä¸‹ã®è¨˜äº‹ã‚’å‚ç…§ã«ã—ã¦ãã ã•ã„ã€‚

https://zenn.dev/tipstar0125/articles/f9c4626cdd4d5b

# Vec

### ã‚ˆãä½¿ã†ãƒ¡ã‚½ãƒƒãƒ‰

#### - enumerate

forã§é…åˆ—ã‚’indexã¨ä¸€ç·’ã«å›ã™ã€‚

```rust
let A = vec![3, 4, 5];
for (i, &a) in A.iter().enumerate() {
    println!("{} {}", i, a);
}
// 0 3
// 1 4
// 2 5
```

#### - rev

forã§é€†å›ã—

```rust
let N = 3;
for i in (0..N).rev() {
    println!("{} ", i);
}
// 2 1 0
let A = vec![3, 4, 5];
for &a in A.iter().rev() {
    println!("{} ", a);
}
// 5 4 3
```

#### - enumerate + rev

```rust
let A = vec![3, 5, 2, 1, 4];
for (i, &a) in A.iter().enumerate().rev() {
    println!("{} {}", i, a);
}
// 4 4
// 3 1
// 2 2
// 1 5
// 0 3
```

```rust
let A = vec![3, 5, 2, 1, 4];
for (i, &a) in A.iter().rev().enumerate() {
    println!("{} {}", i, a);
}
// 0 4
// 1 1
// 2 2
// 3 5
// 4 3
```

#### - max/min

`unwrap()`å¿˜ã‚ŒãŒã¡ã€‚ç©ºã®ã¨ã`panic`ã€‚

```rust
let vec = vec![1, 2, 3];
println!("{}", vec.iter().max().unwrap());  // 3
println!("{}", vec.iter().min().unwrap());  // 1
```

#### - sum

å‹æŒ‡å®šå¿˜ã‚ŒãŒã¡ã€‚

```rust
let vec = vec![1, 2, 3];
println!("{}", vec.iter().sum::<usize>());  // 6
```

#### - swap

indexã‚’æŒ‡å®šã—ã¦å…¥ã‚Œæ›¿ãˆã€‚

```rust
let mut vec = vec![1, 2, 3];
vec.swap(0, 2);
println!("{:?}", vec);  // [3, 2, 1]
```

å¤‰æ•°åŒå£«ã®swapã¯ä»¥ä¸‹ã®é€šã‚Šã€‚

```rust
use std::mem::swap;  // è‡ªå‹•è£œå®Œã§å…¥åŠ›ã•ã‚Œã‚‹ã‚ˆã†ã«è¨­å®šã—ã¦ãŠãã¨ä¾¿åˆ©
let mut a = 0;
let mut b = 1;
swap(&mut a, &mut b);
println!("a:{}, b:{}", a, b);  // a: 1, b: 0
```

#### - extend

è¤‡æ•°ã®é…åˆ—ã‚’é€£çµã™ã‚‹ã€‚å…ƒã®é…åˆ—ã‚’å†åˆ©ç”¨ã™ã‚‹å ´åˆã¯ã€`clone`ã™ã‚‹ã€‚

```rust
let A = vec![1, 2, 3];
let B = vec![4, 5, 6];
let mut C = A;
C.extend(B);
println!("{:?}", C);  // [1, 2, 3, 4, 5, 6]
```

#### - join

é…åˆ—ã‚’æŒ‡å®šæ–‡å­—åŒºåˆ‡ã‚Šã§å‡ºåŠ›ã™ã‚‹ã€‚

```rust
A.iter().join(" ");  // ã‚¹ãƒšãƒ¼ã‚¹åŒºåˆ‡ã‚Š
A.iter().join("\n");  // æ”¹è¡ŒåŒºåˆ‡ã‚Š
```

`itertools`ã®Crateã‚’ä½¿ç”¨ã§ããªã„ç’°å¢ƒ(CF or yukicoderãªã©)ã®ã¨ãã¯ã€`fold`ã§ä»£ç”¨ã™ã‚‹ã€‚

```rust
let s = vec![1, 2, 3, 4, 5];
let s = s
    .iter()
    .fold("".to_string(), |ss, &x| ss + x.to_string().as_str() + " ");  // ã‚¹ãƒšãƒ¼ã‚¹åŒºåˆ‡ã‚Š
println!("{}", s);  // 1 2 3 4 5
```

#### - permutations

é †åˆ—å…¨æ¢ç´¢

```rust
let n = 3;
for p in (0..n).permutations(n) {
    println!("{:?}", p);
}
// [0, 1, 2]
// [0, 2, 1]
// [1, 0, 2]
// [1, 2, 0]
// [2, 0, 1]
// [2, 1, 0]

// ä»¥ä¸‹ã§ã‚‚OK
let vec = vec![0, 1, 2];
for p in vec.iter().permutations(vec.len()) {
    println!("{:?}", p);
}
```

`next_permutation`ã‚„`prev_permutation`ã‚‚ã‚ã‚‹ã€‚

```rust
let mut vec = vec![0, 1, 2];
vec.next_permutation();
println!("{:?}", vec);  // [0, 2, 1]
vec.prev_permutation();
println!("{:?}", vec);  // [0, 1, 2]
```

#### - combinations

çµ„åˆã›ã®å…¨ãƒ‘ã‚¿ãƒ¼ãƒ³ã‚’åˆ—æŒ™

```rust
for c in (0..3).combinations(2) {
    println!("{:?}", c);
}
// [0, 1]
// [0, 2]
// [1, 2]
let vec = vec![1, 2, 3, 3];
for c in vec.iter().combinations(2) {
    println!("{:?}", c);
}
// [1, 2]
// [1, 3]
// [1, 3]
// [2, 3]
// [2, 3]
// [3, 3]
```

ä»¥ä¸‹ã®ã‚ˆã†ã«ã™ã‚‹ã¨bitå…¨æ¢ç´¢ã¨åŒã˜ã“ã¨ãŒã§ãã‚‹ã€‚

```rust
let n = 3;
for i in 1..=n {
    for c in (0..n).combinations(i) {
        println!("{:?}", c);
    }
}
// [0]
// [1]
// [2]
// [0, 1]
// [0, 2]
// [1, 2]
// [0, 1, 2]
```

### ã‚½ãƒ¼ãƒˆ

- æ˜‡é †ã€é™é †

```rust
let mut A = vec![3, 1, 2];
A.sort(); // æ˜‡é †
A.reverse();  // é™é †
A.sort_by(|a, b| a.cmp(b)); // æ˜‡é †
A.sort_by(|a, b| b.cmp(a)); // é™é †
```

- ã‚­ãƒ¼ã‚’æŒ‡å®šã—ã¦ã‚½ãƒ¼ãƒˆ

```rust
let mut A = vec![(1, 3), (2, 1), (3, 2)];
A.sort_by(|(_, a), (_, b)| b.cmp(a)); // ç¬¬2è¦ç´ ã§é™é †

let mut B = vec![("a", 90, 80), ("d", 70, 80), ("c", 90, 60), ("b", 70, 80)];
B.sort_by(|(a0, a1, a2), (b0, b1, b2)| (-a1, a2, a0).cmp(&(-b1, b2, b0)));
// ç¬¬2è¦ç´ ã§é™é †ã€ç¬¬3è¦ç´ ã§æ˜‡é †ã€ç¬¬1è¦ç´ ã§æ˜‡é †ã®å„ªå…ˆåº¦ã§ä¸¦ã³æ›¿ãˆ
// [("c", 90, 60), ("a", 90, 80), ("b", 70, 80), ("d", 70, 80)]

// ãƒã‚¤ãƒŠã‚¹ã‚’ä½¿ç”¨ã™ã‚‹ã¨ã€å‹ã‚’isizeã«ã™ã‚‹å¿…è¦ãŒã‚ã‚‹ãŒã€
// ä»¥ä¸‹ã®ã‚ˆã†ã«Reverseã‚’ä½¿ç”¨ã™ã‚‹ã“ã¨ã§usizeã®ã¾ã¾é™é †ã«ã§ãã‚‹ã€‚
use std::cmp::Reverse;
B.sort_by(|(a0, a1, a2), (b0, b1, b2)| (Reverse(a1), a2, a0).cmp(&(Reverse(b1), b2, b0)));
```

- éƒ¨åˆ†ã‚½ãƒ¼ãƒˆ

`reverse`ã‚„`sort`ã¯ä»¥ä¸‹ã®ã‚ˆã†ã«ã‚¹ãƒ©ã‚¤ã‚¹ã—ã¦ã€éƒ¨åˆ†çš„ã«è¡Œã†ã“ã¨ãŒå¯èƒ½ã€‚

```rust
let mut v = vec![0, 1, 2, 3, 4, 5];
v[2..=4].reverse();
println!("{:?}", v);
// [0, 1, 4, 3, 2, 5]

let mut v = vec![0, 1, 2, 3, 4, 5];
v[2..=4].sort_by(|a, b| b.cmp(a));
println!("{:?}", v);
// [0, 1, 4, 3, 2, 5]
```

- é‡è¤‡å‰Šé™¤

`Vec`ã®é‡è¤‡ã‚’å‰Šé™¤ã™ã‚‹ã¨ãã¯äº‹å‰ã«ã‚½ãƒ¼ãƒˆã™ã‚‹ã€‚
ã‚½ãƒ¼ãƒˆã—ãªã„ã¨ã€å‰Šé™¤ã•ã‚Œãªã„ã€‚ã€‚ã€‚

```rust
let mut A = vec![3, 1, 2];
A.sort();
A.dedup();
```

- æµ®å‹•å°æ•°ç‚¹ã®ã‚½ãƒ¼ãƒˆ

æµ®å‹•å°æ•°ç‚¹ã¯`NaN`ã®å¯èƒ½æ€§ãŒã‚ã‚‹ã®ã§`sort()`ãƒ¡ã‚½ãƒƒãƒ‰ã¯ä½¿ç”¨ã§ããªã„ã€‚`NaN`ã«ãªã‚‰ãªã„ï¼ˆ0å‰²ã‚ŠãŒãªã„ï¼‰ã“ã¨ã‚’è‡ªåˆ†ã§ä¿è¨¼ã™ã‚‹ã“ã¨ã‚’å‰æã¨ã—ã¦ã€ä»¥ä¸‹ã®é€šã‚Šã‚½ãƒ¼ãƒˆã™ã‚‹ã“ã¨ã‚’ãŒã§ãã‚‹ã€‚

```rust
let mut A = vec![10.5, 2.3, 3.5];
//A.sort(); NG
A.sort_by(|a, b| a.partial_cmp(b).unwrap());
println!("{:?}", A);  // [2.3, 3.5, 10.5]
```

### Vecã®å¤‰æ›

```rust
use std::collections::VecDeque;
let A = vec![1, 2, 3];
let mut A: VecDeque<_> = A.iter().cloned().collect();
let mut A: VecDeque<_> = A.into_iter().collect();  // same above
let mut A: VecDeque<_> = A.into();  // same above
let mut set: BTreeSet<_> = A.iter().cloned().collect();
let mut set: BTreeSet<_> = A.into_iter().collect();  //same above
let mut set: BTreeSet<_> = A.into();  // NG

// for 2D
let B = vec![vec![1, 2, 3], vec![4, 5, 6]];
let B: VecDeque<VecDeque<_>> = B.into_iter().map(|v| v.into_iter().collect()).collect();
let B: VecDeque<VecDeque<_>> = B.into_iter().map(|v| v.into()).collect();  // same above
```

### ã‚¹ãƒ©ã‚¤ã‚¹

ä¾‹ãˆã°ã€ç­”ãˆã‚’ä¿å­˜ã—ãŸé…åˆ—ã‚’0ã‹ã‚‰ã§ã¯ãªãã€1ã‹ã‚‰ã‚¹ãƒšãƒ¼ã‚¹åŒºåˆ‡ã‚Šã§å‡ºåŠ›ã—ãŸã„å ´åˆé…ä¸‹ã®é€šã‚Šã€`Range`ã§æŒ‡å®šã™ã‚‹ã€‚

```rust
let ans = vec![1, 2, 3, 4];  // 2 3 4
println!("{}", ans[1..].iter().join(" "));  // 2 3
```

### map

å„é…åˆ—ã«å¯¾ã—ã¦ã€åŒã˜å‡¦ç†ã‚’ã™ã‚‹å ´åˆ`map`ã‚’ä½¿ç”¨ã™ã‚‹ã€‚
ä»¥ä¸‹ã¯ã€0-indexedã§å‡¦ç†ã—ã¦ã„ãŸã‚‚ã®ã‚’ã€1-indexedã«å¤‰æ›ã—ã¦å‡ºåŠ›ã™ã‚‹ä¾‹ã€‚

```rust
let v = vec![0, 1, 2, 3];
println!("{}", v.iter().map(|x| x + 1).join(" "));
// 1 2 3 4
```

### ãã®ä»–é«˜éšé–¢æ•°

```rust
let v = vec![0, 1, 2, 3, 4, 5];

// for_each
let mut v2 = vec![];
v.iter().enumerate().for_each(|(i, x)| {
    if i % 2 == 0 {
        v2.push(x * 2)
    }
});
println!("{:?}", v2); // [0, 4, 8]

// filter
let v3 = v.iter().filter(|&x| x % 2 == 1).collect::<Vec<_>>();
let cnt = v.iter().filter(|&x| x % 2 == 1).count();
println!("{:?}", v3); // [1, 3, 5]
println!("{}", cnt); // 3

// fold(reduceç›¸å½“)
let s = v.iter().fold(0, |sum, x| sum + x); // sumã¨åŒã˜
println!("{}", s); // 15
```

### flatten

```rust
let v1 = vec![vec![0, 1], vec![2, 3, 4]];
let v2 = v1.iter().flatten().collect::<Vec<_>>();
println!("{:?}", v2); // [0, 1, 2, 3, 4]
```

### è»¢ç½®(transpose)

`Vec`ç”¨ã¨`VecDeque`ç”¨ã‚’é–¢æ•°ã§ç”¨æ„ã—ãŸã€‚
â€»ã‚¸ã‚§ãƒãƒªã‚¯ã‚¹ã‚’ä½¿ç”¨ã—ã¦ã€çµ±åˆã—ãŸã„ã€‚ã€‚ã€‚

```rust
fn transpose_vec<T>(v: Vec<Vec<T>>) -> Vec<Vec<T>> {
    assert!(!v.is_empty());
    let N = v[0].len();
    let mut iters: Vec<_> = v.into_iter().map(|n| n.into_iter()).collect();
    (0..N)
        .map(|_| {
            iters
                .iter_mut()
                .map(|n| n.next().unwrap())
                .collect::<Vec<T>>()
        })
        .collect()
}

fn transpose_vec_deque<T>(v: VecDeque<VecDeque<T>>) -> VecDeque<VecDeque<T>> {
    assert!(!v.is_empty());
    let N = v[0].len();
    let mut iters: VecDeque<_> = v.into_iter().map(|n| n.into_iter()).collect();
    (0..N)
        .map(|_| {
            iters
                .iter_mut()
                .map(|n| n.next().unwrap())
                .collect::<VecDeque<T>>()
        })
        .collect()
}

let A = vec![vec![1, 2, 3], vec![4, 5, 6]];
let A = transpose_vec(A);
println!("{:?}", A);
let A: VecDeque<VecDeque<_>> = A.into_iter().map(|v| v.into_iter().collect()).collect();
let A = transpose_vec_deque(A);
println!("{:?}", A);
```

### rotate

`rotate_right`ã¨`rotate_left`ã‚’ä½¿ç”¨ã—ã¦å›è»¢ã§ãã‚‹ã€‚
`Vec`ã¨`VecDeque`ä¸¡æ–¹ã§ä½¿ç”¨å¯èƒ½ã€‚

```rust
let mut A = vec![1, 2, 3, 4, 5, 6];
A.rotate_right(3);
println!("{:?}", A);  // [4, 5, 6, 1, 2, 3]
A.rotate_left(3);
println!("{:?}", A);  // [1, 2, 3, 4, 5, 6]
let mut A: VecDeque<_> = A.into();
A.rotate_right(3);
println!("{:?}", A);  // [4, 5, 6, 1, 2, 3]
A.rotate_left(3);
println!("{:?}", A);  // [1, 2, 3, 4, 5, 6]
```

### lower_bound, upper_bound

```rust
let v = vec![0, 1, 2, 3, 4, 5];
println!("{}", v.lower_bound(&2));  // 2
println!("{}", v.upper_bound(&2));  // 3
// vã®å„è¦ç´ ã‚’2ä¹—ã—ã¦lower_boundã¯ä»¥ä¸‹ã®ã‚ˆã†ã«ã‚¯ãƒ­ãƒ¼ã‚¸ãƒ£ã§æŒ‡å®šã§ãã‚‹
println!("{}", v.lower_bound_by_key(&4, |x| x * x));  // 2
```

### take_while

`while`ã‚’ä½¿ç”¨ã—ã¦`i`ã®2ä¹—ã¾ã§ã€ã‚¤ãƒ³ã‚¯ãƒªãƒ¡ãƒ³ãƒˆã—ã¦ãƒ«ãƒ¼ãƒ—ã‚’å›ã™æ–¹æ³•ã¯ã€`for`ã§`take_while`ã‚’ä½¿ç”¨ã™ã‚‹ã“ã¨ã§ã‚‚æ›¸ãã“ã¨ãŒã§ãã‚‹ã€‚
æ¡ä»¶ã¯ã‚¯ãƒ­ãƒ¼ã‚¸ãƒ£ã«ã¦æŒ‡å®šã™ã‚‹ã€‚

```rust
let N = 16;
let mut i = 0;
while i * i <= N {
    print!("{} ", i);
    i += 1;
}
// 0 1 2 3 4
println!();

for i in (0..).take_while(|x| x * x <= N) {
    print!("{} ", i);
}
// 0 1 2 3 4
println!();

let v = vec![2, 3, 5, 7, 11, 13];
for (i, &p) in v.iter().enumerate().take_while(|x| x.1 * x.1 <= N) {
    println!("{} {}", i, p);
}
// 0 2
// 1 3
```

### windows

é…åˆ—ã®è¤‡æ•°è¦ç´ ã‚’å‡¦ç†ã—ãŸã„å ´åˆã«ä½¿ç”¨ã™ã‚‹ã€‚

```rust
let v = vec![0, 1, 2, 3, 4, 5];
for x in v.windows(2) {
    let x0 = x[0];
    let x1 = x[1];
    println!("x0: {}, x1: {}", x0, x1);
}
// x0: 0, x1: 1
// x0: 1, x1: 2
// x0: 2, x1: 3
// x0: 3, x1: 4
// x0: 4, x1: 5

let v2 = v.windows(2).map(|x| x[0] + x[1]).collect::<Vec<_>>();
println!("{:?}", v2);
// [1, 3, 5, 7, 9]
```

### position

è¦ç´ ã‚’å·¦ã¾ãŸã¯å³ã‹ã‚‰æ¢ã—ã¦ã€è¦‹ã¤ã‹ã£ãŸã¨ãã®indexã‚’è¿”ã™ã€‚

```rust
let v = vec![1, 2, 3, 2, 3, 2, 1];
let pos = v.iter().position(|&x| x == 2).unwrap();
println!("{}", pos);
let pos = v.iter().rposition(|&x| x == 2).unwrap();
println!("{}", pos);
```

# æ–‡å­—åˆ—

### chars

`String`ã‚’1æ–‡å­—ãšã¤å‡¦ç†ã™ã‚‹ã«ã¯ã€`chars()`ã‚’ä½¿ç”¨ã™ã‚‹ã€‚

```rust
let S = "abc".to_string();
// let S = "abc"; &strã®ã¾ã¾ã§ã‚‚OK
for c in S.chars() {
    print!("{} ", c);  // a b c
}
```

`proconio`ã®`Chars`ã¯ã€`Rust`æ¨™æº–ã®`Chars`ã¨ã¯ç•°ãªã‚Šã€`Vec<char>`ã§ã‚ã‚‹ã€‚
`Vec<char>`ã‚’ç”Ÿæˆã™ã‚‹å ´åˆã¯ä»¥ä¸‹ã®é€šã‚Šã¨ã™ã‚‹ã€‚

```rust
let s = "abc".chars();  // Chars
let ss = "abc".chars().collect_vec();  // Vec<char>
```

### String or &str-> num

```rust
let s = "1";  // &str
let num: usize = s.parse().unwrap();
println!("{}", num);  // 1
let s = "2".to_string();  // String
let num: usize = s.parse().unwrap();
println!("{}", num);  // 2
```

### Vec<char> -> String

```rust
let C = ['a', 'b', 'c'];
let S = C.iter().collect::<String>();  // "abc"
```

### æ–‡å­—åè»¢

```rust
let S = "abc".to_string();
let S_rev = S.chars().rev().collect::<String>();
println!("{}", S_rev);  // cba
```

### ã‚¹ãƒ©ã‚¤ã‚¹

```rust
let S = "abc".to_string();
println!("{}", &S[1..]);  // bc
println!("{}", &S[..2]);  // ab
```

### æ–‡å­—ã‚’abc...ã®é †ã«æ•°å€¤ã«å¤‰æ›

```rust
let s = 'a';
println!("{}", s as u8 - b'a' + 1);  // 1
let s = 'B';
println!("{}", s as u8 - b'A' + 1);  // 2, 2023/02/14 modified
```

`u8`ã‚’`char`ã«æˆ»ã™å ´åˆã¯ã€`char`ã§ã‚­ãƒ£ã‚¹ãƒˆã™ã‚Œã°ã‚ˆã„ã€‚

```rust
let s = 'A';
let s_num = s as u8;
println!("{}", s_num as char);  // A
```

### né€²æ•°æ–‡å­—åˆ—ã‚’æ•°å€¤ã«å¤‰æ›

```rust
let s = "1010";
let num = usize::from_str_radix(s, 2).unwrap();
println!("{}", num);  // 10

let s = vec!['1', 'F'];
let s = s
    .iter()
    .fold("".to_string(), |ss, &x| ss + x.to_string().as_str());
println!("{}", s);
let num = usize::from_str_radix(s.as_str(), 16).unwrap();
println!("{}", num);  // 31
```

# BTreeSet/BTreeMap

åŒã˜ã‚ˆã†ãªã“ã¨ãŒã§ãã‚‹`HashSet`ã¨`HashMap`ãŒã‚ã‚‹ãŒã€ãƒ‡ãƒãƒƒã‚°ã™ã‚‹ã¨ãã«ã€æ˜‡é †ã«ä¸¦ã‚“ã§ã„ãŸæ–¹ãŒåˆ†ã‹ã‚Šã‚„ã™ã„ã€äºŒåˆ†æ¢ç´¢ãŒã§ãã‚‹ã€ã¨ã„ã†ãƒ¡ãƒªãƒƒãƒˆãŒã‚ã‚‹ã®ã§ã€`BTreeSet`ã¨`BTreeMap`ã‚’ä½¿ç”¨ã™ã‚‹ã€‚

### BTreeMapã®åˆæœŸåŒ–
åˆæœŸåŒ–ã®éš›ã€å‹ã‚’å®šç¾©ã—ãªãã¦ã‚‚ã€é¡æ¨ã—ã¦ãã‚Œã‚‹ãŒã€Pythonã§ã„ã†`defaultdict`ã®ã‚ˆã†ãªä½¿ã„æ–¹ã‚’ã™ã‚‹ãŸã‚ã«ã€å‹å®šç¾©ã™ã‚‹ã€‚

```rust
let mut map: BTreeMap<usize, usize> = BTreeMap::new();
for &a in &A {
    *map.entry(a).or_default() += 1;  // ãƒ‡ãƒªãƒ•ã‚¡ãƒ¬ãƒ³ã‚¹ãŒå¿…è¦, åˆæœŸå€¤ï¼š0
}
```

```rust
let mut map: BTreeMap<usize, Vec<usize>> = BTreeMap::new();
for (i, &a) in A.iter().enumerate() {
    map.entry(a).or_default().push(i + 1);  // åˆæœŸå€¤ï¼šç©ºé…åˆ—
}
```

### å…ˆé ­ãƒ»æœ«å°¾ã®å–å¾—

```rust
let mut set = BTreeSet::new();
set.insert(10);
set.insert(20);
set.insert(30);
println!("{}", set.iter().next().unwrap());  // 10
println!("{}", set.iter().next_back().unwrap());  // 30

let mut map: BTreeMap<usize, usize> = BTreeMap::new();
*map.entry(10).or_default() = 30;
*map.entry(20).or_default() = 20;
*map.entry(30).or_default() = 10;
println!("{:?}", map.iter().next().unwrap());  // (10, 30)
println!("{:?}", map.iter().next_back().unwrap());  // (30, 10)
```

### ãƒªã‚»ãƒƒãƒˆ
`BTreeSet`ã‚„`BTreeMap`ã‚’ç©ºã«ã™ã‚‹ã«ã¯`clear()`ã‚’ä½¿ç”¨ã™ã‚‹ã€‚

```rust
set.clear();
map.clear();
```

### äºŒåˆ†æ¢ç´¢

`HashSet`ã§ã¯`lower_bound`ãŒä½¿ç”¨ã§ããªã„ã€‚ä»£ã‚ã‚Šã«`BTreeSet`ã®`range`ã‚’ä½¿ç”¨ã™ã‚‹ã€‚ä»¥ä¸‹ã¯`BTreeSet`ã®ä¾‹ã ãŒã€`BTreeMap`ã®ã‚­ãƒ¼ã§ã‚‚åŒã˜ã“ã¨ãŒã§ãã‚‹ã€‚

```rust
let mut set = BTreeSet::new();
let value = set.range(x..).next().unwrap(); // lower_boundç›¸å½“
let value = set.range(..x).next_back().unwrap();  // xã‚ˆã‚Šå°ã•ã„è¦ç´ ã®ä¸­ã§æœ€å¤§ã®è¦ç´ 
let iter = set.range(x..=y);  // xä»¥ä¸Šyä»¥ä¸‹

let v = vec![0, 1, 2, 3, 4, 5];
let mut set: BTreeSet<usize> = v.into_iter().collect();
// 3ä»¥ä¸‹ã®é€†é †ã€3ç•ªç›®ï¼ˆ0-indexedï¼‰
let a = set.range(..=3).rev().nth(3).unwrap();
println!("{}", a);  // 0
// 2ä»¥ä¸Šã€2ç•ªç›®ï¼ˆ0-indexedï¼‰
let b = set.range(2..).nth(2).unwrap();
println!("{}", b);  // 4
```

### é›†åˆã®è¨ˆç®—

è¨ˆç®—å¾Œã®å‹ãŒå¤‰ã‚ã‚‰ãšã€ä½¿ã„ã¾ã‚ã›ã‚‹ä»¥ä¸‹ã‚’ä½¿ç”¨ã™ã‚‹ã€‚

```rust
let mut set = BTreeSet::new();
let mut set1 = BTreeSet::new();
set1.insert(1);
set1.insert(2);
set1.insert(3);
let mut set2 = BTreeSet::new();
set2.insert(1);
set2.insert(2);
set2.insert(4);
set = &set1 | &set2;  // å’Œ
println!("{:?}", set);  // {1, 2, 3, 4}
set = &set1 - &set2;  // å·®
println!("{:?}", set);  // {3}
set = &set1 & &set2;  // ç©
println!("{:?}", set);  // {1, 2}
set = &set1 ^ &set2;  // å¯¾ç§°å·®
println!("{:?}", set);  // {3, 4}
```

ä»¥ä¸‹ã¯è¨ˆç®—å¾Œã®å‹ãŒ`HashSet`ã‚„`BTreeSet`ã§ã¯ãªãã€`Union`ã¨ã‹ã«ãªã‚‹ã®ã§ã€ä½¿ã„é“ãªã•ãã†??
è¨ˆç®—çµæœã‚’ä½¿ã„ã¾ã‚ã—ãŸã„å ´åˆã«éƒ½åˆãŒæ‚ªã„ã€‚`into_iter().copied().collect()`ã§å¤‰æ›ã§ãã‚‹ã‘ã©ã€é¢å€’ã€‚

```rust
a.union(&b)  // å’Œ
a.difference(&b)  // å·®
a.intersection(&b)  // ç©
a.symmetric_difference(&b)  // å¯¾ç§°å·®
```

# ã‚°ãƒ©ãƒ•

### ã‚°ãƒ©ãƒ•ã®é ‚ç‚¹ãŒæ–‡å­—åˆ—ã‚„å¤§ããªæ•°å€¤ã®ã¨ãã®å¤‰æ›

ã‚°ãƒ©ãƒ•ã®é ‚ç‚¹ãŒæ–‡å­—åˆ—ã‚„å¤§ããªæ•°å€¤ã®ã¨ãã¯ã€éš£æ¥ãƒªã‚¹ãƒˆã‚’é…åˆ—ã§ã¯ãªãã€`HashMap`ã§ä½œã‚‹ã“ã¨ã§å‡¦ç†ã§ãã‚‹ãŒã€ä»¥ä¸‹ã®ã‚ˆã†ã«å¤‰æ›ã™ã‚‹`HashMap`ã‚’ã¤ãã‚Šã€éš£æ¥ãƒªã‚¹ãƒˆã‚’é…åˆ—ã§ä½œã‚‹ã“ã¨ãŒã§ãã‚‹ã€‚ã‚­ãƒ¼ã¯ãƒ¦ãƒ‹ãƒ¼ã‚¯ãªã®ã§ã€åŒã˜ã‚­ãƒ¼ã®ã‚‚ã®ã¯å‰Šé™¤ã•ã‚Œã‚‹ãŒã€ã‚½ãƒ¼ãƒˆã—ã¦ã€ãƒ¦ãƒ‹ãƒ¼ã‚¯ã«ã—ã¦ãŠãã€‚

```rust
let mut x = vec![];
let ST = vec![
    ("a".to_string(), "b".to_string()),
    ("b".to_string(), "c".to_string()),
    ("d".to_string(), "a".to_string()),
];
for (s, t) in &ST {
    x.push(s.as_str());
    x.push(t.as_str());
}
x.sort();
x.dedup();

let map: BTreeMap<_, _> = x.iter().enumerate().map(|(i, &s)| (s, i)).collect();
println!("{:?}", map);
// {"a": 0, "b": 1, "c": 2, "d": 3}
```

# æµ®å‹•å°æ•°ç‚¹

### min/max

`f64`ã§`min/max`ã‚’ä½¿ã†ã¨ã€ä»¥ä¸‹ã®ã‚ˆã†ãªã‚¨ãƒ©ãƒ¼ã«é­é‡ã™ã‚‹ã“ã¨ãŒã‚ã‚‹ã€‚

> can't call method `min` on ambiguous numeric type `{float}`

ä»¥ä¸‹ãŒã‚¨ãƒ©ãƒ¼ã«ãªã‚‹ä¾‹ã€‚

```rust
let a = 1.0;
let b = 2.0;
let c = a.min(b);  // Error
let v = vec![1.0, 2.0, 3.0];
let a = v[0].min(2.0);  // Error
```

ä»¥ä¸‹ã®ã‚ˆã†ã«å‹æŒ‡å®šã‚’ã™ã‚‹ã¨ã€ã‚¨ãƒ©ãƒ¼ãŒè§£æ¶ˆã•ã‚Œã‚‹ã€‚ã‚‚ã—ãã¯ã€æ¬¡ã§ç´¹ä»‹ã—ã¦ã„ã‚‹`NotNan`ã‚’ä½¿ç”¨ã™ã‚‹ã€‚

```rust
let a: f64 = 1.0;
let b: f64 = 2.0;
let c = a.min(b);
let v: Vec<f64> = vec![1.0, 2.0, 3.0];
let a = v[0].min(2.0);
```

### ordered float

`f64`ã¯ã€`NaN`ã®å¯èƒ½æ€§ãŒã‚ã‚Šã€`std::cmp::Ord`ã‚’ãƒˆãƒ¬ã‚¤ãƒˆã«æŒãŸãªã„ãŸã‚ã€`sort`ã—ãŸã‚Šã€`BinaryHeap`ã«pushã§ããªã‹ã£ãŸã‚Šã€ä¸éƒ½åˆãªå ´åˆãŒã‚ã‚‹ã€‚`NaN`ã«ãªã‚‰ãªã„ã“ã¨ã‚’è‡ªåˆ†ã§ä¿è¨¼ã™ã‚‹ã“ã¨ã‚’æ¡ä»¶ã«ã€ä»¥ä¸‹ã®`NotNan`ã‚’ä½¿ç”¨ã™ã‚‹ã“ã¨ãŒã§ãã‚‹ã€‚

```rust
use std::cmp::Reverse;
use std::collections::BinaryHeap;
use std::ops;

use itertools::Itertools;
use ordered_float::NotNan;

let mut v = vec![];
let mut heap = BinaryHeap::new();
for i in (0..5).rev() {
    let x = NotNan::new(i as f64 + 0.1).unwrap();
    v.push(x);
    heap.push(Reverse(x));
}
println!("{}", v.iter().join(" "));  // 4.1 3.1 2.1 1.1 0.1
v.sort();
println!("{}", v.iter().join(" "));  // 0.1 1.1 2.1 3.1 4.1
println!("{:?}", heap);
// [Reverse(NotNan(0.1)), Reverse(NotNan(1.1)), Reverse(NotNan(3.1)), Reverse(NotNan(4.1)), Reverse(NotNan(2.1))]
```

ä»¥ä¸‹ã®ã‚ˆã†ã«`f64`ã¨`NotNan<f64>`ã¯æ¼”ç®—å¯èƒ½ãªã®ã§ã€å¸¸ã«`NotNan::new()`ã¯ã—ãªãã¦ã‚‚è‰¯ã„ã€‚

```rust
let a = NotNan::new(1.0).unwrap();
let b = 2.0;
let c = a + b;
println!("{}", c); // 3.0
```

### ä¸‰è§’é–¢æ•°

```rust
let theta = 180.0;
println!("{}", theta.to_radians());  // 3.141592653589793
let theta = theta.to_radians();
println!("{}", theta.to_degrees());  // 180

let theta = (180.0).to_radians();
println!("{}", theta.sin());  // 0.00000000000000012246467991473532
println!("{}", theta.cos());  // -1
```

# ãã®ä»–

### ã‚¿ãƒ—ãƒ«åˆ†å‰²ä»£å…¥

```rust 
input! {
    N: usize,
    LR: [(usize, usize); N]
}

for i in 0..N {
    let l = LR[i].0;
    let r = LR[i].1;
    // ä¸Šè¿°ã§ã‚‚è‰¯ã„ãŒã€ä»¥ä¸‹ã®ã‚ˆã†ã«åˆ†å‰²ä»£å…¥å¯èƒ½
    let (l, r) = LR[i];
    let (mut l, mut r) = LR[i]; // å€¤ã‚’å¤‰æ›´ã™ã‚‹å ´åˆ
}
```

### ãƒ‘ã‚¿ãƒ¼ãƒ³ãƒãƒƒãƒ

```rust
// queryã®ç¬¬ä¸€è¦ç´ ã§ã‚¯ã‚¨ãƒªã®ãƒ‘ã‚¿ãƒ¼ãƒ³(1 or 2 or 3)ã‚’æŒ‡å®šã—ã€ãã®ä»–ã®è¦ç´ ï¼ˆå¼•æ•°ï¼‰ã§å‡¦ç†
for &q in &query {
    match q {
        (1, x, y) => {
            // something
        }
        (2, _, _) => {
            // something
        }
        (3, x, _) => {
            // something
        }
        (_, _, _) => unreachable!(),
    }
}
```

### å¤§ãã„æ•°ã®è¨­å®š

`1,000,000,007`ã¨ã‹ã®0ã®æ•°ã®å¤§ãã„è¨­å®šã¯ä»¥ä¸‹ã®é€šã‚Šã€çœç•¥ã—ã¦æ›¸ã‘ã‚‹ã€‚

```rust
let MOD = 1e9 as usize + 7;
```

### eprint!/eprintln!

- ãƒ‡ãƒãƒƒã‚°

ãƒ‡ãƒãƒƒã‚°ã®éš›ã€`print!` or `println!`ã‚’ä½¿ç”¨ã™ã‚‹ã¨ã€æå‡ºã®éš›ã«å‰Šé™¤ã™ã‚‹å¿…è¦ãŒã‚ã‚‹ãŒã€æ¨™æº–ã‚¨ãƒ©ãƒ¼å‡ºåŠ›ãƒã‚¯ãƒ­ã§ã‚ã‚‹`eprint!` or `eprintln!`ã‚’ä½¿ç”¨ã™ã‚Œã°ã€ãã®ã¾ã¾æå‡ºã™ã‚‹ã“ã¨ãŒå¯èƒ½ã€‚

- ãƒãƒ«ãƒãƒ†ã‚¹ãƒˆã‚±ãƒ¼ã‚¹

ãƒãƒ«ãƒãƒ†ã‚¹ãƒˆã‚±ãƒ¼ã‚¹ã®å•é¡Œã®éš›ã€ã‚¿ãƒ¼ãƒŸãƒŠãƒ«ãŒæ¨™æº–å…¥åŠ›ã¨æ¨™æº–å‡ºåŠ›ã§æ··ã–ã£ã¦ã—ã¾ã„ã€ã©ã‚ŒãŒæ¨™æº–å‡ºåŠ›ã‹ã‚ã‹ã‚‰ãªããªã‚‹å ´åˆãŒã‚ã‚‹ã€‚
æ¨™æº–å‡ºåŠ›ã®å‰ã«ä»¥ä¸‹ã®ã‚ˆã†ã«æ¨™æº–ã‚¨ãƒ©ãƒ¼å‡ºåŠ›ã§ç›®å°ã‚’ã¤ã‘ã¦ãŠã‘ã°ã€ç°¡å˜ã«ç¢ºèªã§ãã‚‹ã€‚

```rust
eprint!("ans: ");
println!("{}", ans);
```

### is_aresã®åˆ¤å®š

äºŒæ¬¡å…ƒç›¤é¢ã«ãŠã„ã¦ã€ç›¤é¢ã®ç¯„å›²å†…ã‹ã©ã†ã‹ã‚’åˆ¤å®šã™ã‚‹ã¨ãã€å‹ãŒ`usize`ã®ã¾ã¾ã ã¨ã€`subtract`ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¦ã—ã¾ã†ãŸã‚ã€`isize`ã«å¤‰æ›´ã—ã¦åˆ¤å®šã™ã‚‹å¿…è¦ãŒã‚ã‚‹ãŒã€é…åˆ—ã®æŒ‡å®šã¯`usize`ã§æŒ‡å®šã™ã‚‹å¿…è¦ãŒã‚ã‚‹ã®ã§ã€ç¯„å›²å†…ã§ã‚ã£ãŸã‚‰ã€å†åº¦`usize`ã«æˆ»ã™ã€ã¨ã„ã†ã‚ˆã†ã«å‡¦ç†ãŒé¢å€’ã€‚
ãã“ã§ã€ã‚ªãƒ¼ãƒãƒ¼ãƒ•ãƒ­ãƒ¼ã‚’ç„¡è¦–ã§ãã‚‹`wrapping_add`ã‚„`wrapping_mul`ã‚’ç”¨ã„ã¦ã€`usize`ã®ã¾ã¾ã§ã€`!0`ï¼ˆæœ€å¤§æ•°ã‚’åŠ ç®—ï¼1æ¸›ç®—ï¼‰ã®å‡¦ç†ãŒå¯èƒ½ã€‚

```rust
const DIJ4: [(usize, usize); 4] = [(!0, 0), (0, !0), (1, 0), (0, 1)];

fn main() {

    let is_area = |row: usize, col: usize, dr: usize, dc: usize| -> bool {
        let r = row.wrapping_add(dr);
        let c = col.wrapping_add(dc);
        if r >= H {
            return false;
        }
        if c >= W {
            return false;
        }
        true
    };

    for i in 0..H {
        for j in 0..W {
            for &(dr, dc) in &DIJ4 {
                if !is_area(i, j, dr, dc) {
                    continue;
                }
                // å‡¦ç†
            }
        }
    }
}
```

è¤‡æ•°å›åŠ ç®—ãƒ»æ¸›ç®—ã™ã‚‹å ´åˆã¯ã€ä»¥ä¸‹ã®é€šã‚Š`wrapping_mul`ã‚’ä½¿ç”¨ã™ã‚‹ã€‚ä»¥ä¸‹ã¯ã€`num`ã®æ•°ã ã‘åŠ ç®—ãƒ»æ¸›ç®—ã™ã‚‹ã€‚

```rust
let is_area = |row: usize, col: usize, dr: usize, dc: usize, num: usize| -> bool {
    let r = row.wrapping_add(dr.wrapping_mul(num));
    let c = col.wrapping_add(dc.wrapping_mul(num));
    if r >= H {
        return false;
    }
    if c >= W {
        return false;
    }
    true
};
```

### ãƒ†ã‚­ã‚¹ãƒˆãƒ•ã‚¡ã‚¤ãƒ«ã§å…¥å‡ºåŠ›

ãƒãƒ«ãƒãƒ†ã‚¹ãƒˆã‚±ãƒ¼ã‚¹ã®æ¨™æº–å‡ºåŠ›ã®æ”¹å–„æ¡ˆã¨ã—ã¦ã€æ¨™æº–ã‚¨ãƒ©ãƒ¼å‡ºåŠ›ã™ã‚‹ä»¥å¤–ã«ä»¥ä¸‹ã®é€šã‚Šã€å®Ÿè¡Œã®éš›ã«ã‚³ãƒãƒ³ãƒ‰ã§ãƒ•ã‚¡ã‚¤ãƒ«ã¸ã®æ›¸ãå‡ºã—æŒ‡ç¤ºã‚’ã—ã¦ã‚‚ã‚ˆã„ã€‚
`out`ã¨ã„ã†ãƒ•ã‚¡ã‚¤ãƒ«ãŒå‡ºåŠ›ã•ã‚Œã‚‹ï¼ˆæ—¢ã«ã‚ã‚‹å ´åˆã¯ä¸Šæ›¸ãã•ã‚Œã‚‹ï¼‰ã€‚

```bash
cargo run > out
```

ãƒ‡ãƒãƒƒã‚°ã‚’ä½•å›ã‚‚å®Ÿæ–½ã™ã‚‹ã“ã¨ãŒã‚ã‚Šã€å…¥åŠ›æŒ‡ç¤ºãŒé¢å€’ãªå ´åˆã¯ã€`in`ãƒ•ã‚¡ã‚¤ãƒ«ã‚’äºˆã‚ã¤ãã£ã¦ãŠãã€ãã®ä¸­ã«å…¥åŠ›æƒ…å ±ã‚’ä¿å­˜ã—ã€ä»¥ä¸‹ã®ã‚³ãƒãƒ³ãƒ‰ã«ã‚ˆã‚Šèª­ã¿è¾¼ã‚€ã€‚

```bash
cargo run < in
cargo run < in > out
```

### ã‚¤ãƒ³ã‚¿ãƒ©ã‚¯ãƒ†ã‚£ãƒ–å…¥åŠ›

`proconio`ã®`input`ãƒã‚¯ãƒ­ã‚’ãã®ã¾ã¾ä½¿ç”¨ã™ã‚‹ã“ã¨ãŒã§ãã¾ã›ã‚“ã€‚
ä»¥ä¸‹ã®ã‚ˆã†ã«ã€`input`ãƒã‚¯ãƒ­ã‚’ç½®ãæ›ãˆã¦ä½¿ã„ã¾ã™ã€‚ã¾ãŸã€ã‚¤ãƒ³ã‚¿ãƒ©ã‚¯ãƒ†ã‚£ãƒ–å…¥åŠ›æ™‚ã¯`proconio`ã®`fastout`ã¯ä½¿ç”¨ã§ããªã„ã®ã§ã€ã‚³ãƒ¡ãƒ³ãƒˆã‚¢ã‚¦ãƒˆã™ã‚‹ã“ã¨ã‚’å¿˜ã‚Œãªã„ã‚ˆã†ã«ã—ã¾ã—ã‚‡ã†ï¼

ç½®ãæ›ãˆã‚‹æ–¹æ³•ã¯2ã¤ã‚ã‚Šã¾ã™ã€‚

- æ–¹æ³•1

```rust
macro_rules! input(($($tt:tt)*) => (
    let stdin = std::io::stdin();
    let mut stdin = proconio::source::line::LineSource::new(std::io::BufReader::new(stdin));
    proconio::input!(from &mut stdin, $($tt)*);
));

fn main() {
    input! {
        N: usize
    }

    while å¼ã€€{
        input {
            S: usize
        }
        // å‡¦ç†
        println!("{}", query);
    }
    println!("{}", ans);
}
```

- æ–¹æ³•2

å…¥åŠ›ãƒ­ãƒƒã‚¯ã‚’è§£æ”¾ã™ã‚‹å¿…è¦ãŒã‚ã‚‹ã®ã§ã€åŸºæœ¬ã¯æ–¹æ³•1ã®ä½¿ç”¨ã‚’æ¨å¥¨ã€‚
æ–¹æ³•2ã¯ã€å…¥åŠ›ã®ä¸€éƒ¨ã‚’ã‚°ãƒ­ãƒ¼ãƒãƒ«å¤‰æ•°ã«ä½¿ç”¨ã™ã‚‹éš›ã«ã‚‚æµç”¨ã§ãã‚‹åˆ©ç‚¹ãŒã‚ã‚‹ã€‚

```rust
macro_rules! input(($($tt:tt)*) => (
    let stdin = std::io::stdin();
    let mut stdin = proconio::source::line::LineSource::new(stdin.lock());
    proconio::input!(from &mut stdin, $($tt)*);
));

fn main() {
    // ãƒ–ãƒ­ãƒƒã‚¯ã§å›²ã‚“ã§å…¥åŠ›ãƒ­ãƒƒã‚¯ã‚’è§£æ”¾
    let N = {
        input! {
            n: usize
        }
        n
    };

    // è¤‡æ•°ã®å ´åˆ
    // let (N, M, T) = {
    //     input! { _n: usize, _m: usize, _t: usize, }
    //     (_n, _m, _t)
    // };

    while å¼ã€€{
        // whileã®ãƒ–ãƒ­ãƒƒã‚¯ã§å›²ã¾ã‚Œã¦ã„ã‚‹ã®ã§è§£æ”¾ä¸è¦
        input {
            S: usize
        }
        // å‡¦ç†
        println!("{}", query);
    }
    println!("{}", ans);
}
```

### å…¥åŠ›ã®ä¸€éƒ¨ã‚’ã‚°ãƒ­ãƒ¼ãƒãƒ«å¤‰æ•°

`proconio`ã®`input`ãƒã‚¯ãƒ­ã®ç½®ãæ›ãˆã¯ã€ã‚¤ãƒ³ã‚¿ãƒ©ã‚¯ãƒ†ã‚£ãƒ–å…¥åŠ›ã®æ–¹æ³•2ã‚’ä½¿ç”¨ã—ã¾ã™ã€‚
`lazy_static`ãƒã‚¯ãƒ­ã‚’ä½¿ç”¨ã—ã¦ã€é…å»¶è©•ä¾¡ã«ã‚ˆã‚Šã€ã‚°ãƒ­ãƒ¼ãƒãƒ«å¤‰æ•°ã‚’å®Ÿç¾ã—ã¦ã„ã¾ã™ã€‚
å‡¦ç†ã®æœ€åˆã«å…¥åŠ›åˆ¶å¾¡ã®å‘½ä»¤ã‚’ã™ã‚‹ã®ã‚’å¿˜ã‚Œãªã„ã“ã¨ï¼

```rust
use lazy_static::lazy_static;

macro_rules! input(($($tt:tt)*) => (
    let stdin = std::io::stdin();
    let mut stdin = proconio::source::line::LineSource::new(stdin.lock());
    proconio::input!(from &mut stdin, $($tt)*);
));

lazy_static! {
    static ref N: usize = {
        input! { n: usize }
        n
    };
}

fn main() {
    // å…¥åŠ›åˆ¶å¾¡å‘½ä»¤
    lazy_static::initialize(&N);

    let A = {
        input! { a: [usize; *N] }
        a
    };

    while å¼ã€€{
        // whileã®ãƒ–ãƒ­ãƒƒã‚¯ã§å›²ã¾ã‚Œã¦ã„ã‚‹ã®ã§è§£æ”¾ä¸è¦
        input {
            S: usize
        }
        // å‡¦ç†
        println!("{}", query);
    }
    println!("{}", ans);
}
```

ã‚°ãƒ­ãƒ¼ãƒãƒ«å¤‰æ•°ãŒè¤‡æ•°ã®å ´åˆã¯ã€ä»¥ä¸‹ã®é€šã‚Šã€‚

```rust
lazy_static! {
    static ref _INPUT: (usize, usize) = {
        input! { n: usize, m: usize, }
        (n, m)
    };
    static ref N: usize = _INPUT.0;
    static ref M: usize = _INPUT.1;
}

fn main() {
    // å…¥åŠ›åˆ¶å¾¡å‘½ä»¤
    lazy_static::initialize(&INPUT);

    let (A, B) = {
        input! { a: [usize; *N], b: [usize; *M] }
        (a, b)
    };

    while å¼ã€€{
        // whileã®ãƒ–ãƒ­ãƒƒã‚¯ã§å›²ã¾ã‚Œã¦ã„ã‚‹ã®ã§è§£æ”¾ä¸è¦
        input {
            S: usize
        }
        // å‡¦ç†
        println!("{}", query);
    }
    println!("{}", ans);
}
```


### åµŒã‚ŠãŒã¡ãªã‚¨ãƒ©ãƒ¼

- subtract with overflow

å‹ãŒ`usize`ã®ã¨ãã€å¼•ãç®—ã‚’ä½¿ç”¨ã—ãŸçµæœã€è² ã®å€¤ã«ãªã‚‹ã¨ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã™ã‚‹ã€‚`isize`ã‚’ä½¿ç”¨ã™ã‚‹ã‹ã€ç§»é …ã—ã¦å¼•ãç®—ã‚’ä½¿ç”¨ã—ãªã„ã‚ˆã†ã«å·¥å¤«ã™ã‚‹å¿…è¦ãŒã‚ã‚‹ã€‚

```rust
input! {
    N: usize,
    A: [usize; N]
}

for i in 0..N {
    // è² ã®å€¤ã«ãªã‚‹ã‚ˆã†ãªè¨ˆç®—ã‚’ã•ã›ãªã„
    if a - b > 0 {} // NG
    if a > b {} // OK
    
    // è² ã«ãªã‚‰ãªã„ã“ã¨ã‚’ç¢ºèªã—ã¦ã‹ã‚‰indexæŒ‡å®šã™ã‚‹
    if A[a-b] > c {}  //NG
    if a > b && A[a-b] > c {}  //OK
    
    // é…åˆ—ã®indexã‚’æŒ‡å®šã™ã‚‹å¤‰æ•°ã®å‹ãŒisizeã®å ´åˆã¯ã€asã§usizeã«å¤‰æ›´
    A[d as usize]
}

```

- å‹æ¨è«–ã§ã€å‹ãŒi32ã¨ã‹ã«ãªã‚‹å ´åˆã€ã‚ªãƒ¼ãƒãƒ¼ãƒ•ãƒ­ãƒ¼ã«ã‚ˆã‚Šã€WAã«ãªã‚‹ã®ã§ã€å‹ã‚’æŒ‡å®š

i32ãŒæ‰±ãˆã‚‹æ•°ã®ä¸Šé™ã‚’è¶…ãˆã¦ã—ã¾ã†å ´åˆã€ã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ ã¯æ­£ã—ãã§ã‚‚WAã«ãªã£ã¦ã—ã¾ã„ã€ä½•ãŒåŸå› ã§WAãŒå‡ºã¦ã„ã‚‹ã®ã‹åˆ†ã‹ã‚‰ãªããªã‚‹ã®ã‚’é˜²ããŸã‚ã«ã€æ„è­˜ã—ã¦ãŠã„ãŸæ–¹ãŒè‰¯ã„ã€‚ã¾ãŸã€ãªãœWAã«ãªã£ãŸã®ã‹åŸå› ä¸æ˜ãªå ´åˆã¯ã€å¤‰æ•°ã«ãƒ›ãƒãƒ¼ã—ã¦ã€æ„å›³ã—ã¦ã„ãªã„å‹ã«ãªã£ã¦ã„ãªã„ã‹ç¢ºèªã™ã‚‹ã€‚

```rust
// ã“ã‚Œã ã‘ã ã¨å‹æ¨è«–ã§i32ã«ãªã‚‹å ´åˆãŒã‚ã‚‹
let mut ans = 0; // NG(å³å¯†ã«ã¯ã“ã‚Œã§å•é¡Œãªã„å ´åˆã‚‚ã‚ã‚‹)
let mut ans: usize = 0; // OK
let mut ans = 0_usize; // OK
```
