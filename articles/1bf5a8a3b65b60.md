---
title: "ã€Rustã€‘AtCoder ABC276(A-E)ã‚’æ·±å €ã£ã¦ã¿ãŸ"
emoji: ğŸƒ
type: "tech"
topics: ["rust", "AtCoder", "ç«¶ãƒ—ãƒ­"]
published: true
---

ä»¥ä¸‹ã®è¨˜äº‹ã®ç¶šç·¨ã§ã™ã€‚å¿…è¦ã«å¿œã˜ã¦å‚è€ƒã«ã—ã¦ãã ã•ã„ã€‚

https://zenn.dev/tipstar0125/articles/4589f2d49b065f
https://zenn.dev/tipstar0125/articles/f9c4626cdd4d5b

ABC274, 275ã¨ã‚³ãƒ³ãƒ†ã‚¹ãƒˆã«å‚åŠ ã—ã¦ã€ä»Šå›ã§3å›ç›®ã®å‚åŠ ã«ãªã‚Šã¾ã™ã€‚
ç›®æ¨™ã¯3å®Œã‚’ãƒŸãƒ‹ãƒãƒ ã¨ã—ã¦ã€4å®Œã§ãã‚Œã°ã¨æ€ã£ã¦ã„ã¾ã—ãŸãŒã€çµæœã¨ã—ã¦ã¯3å®Œã¨ã„ã†çµæœã«çµ‚ã‚ã£ã¦ã—ã¾ã„ã¾ã—ãŸã€‚ã€‚ã€‚Då•é¡Œã¯ã€ã‚³ãƒ³ãƒ†ã‚¹ãƒˆçµ‚äº†å¾Œ3åˆ†å¾Œãã‚‰ã„ã«è‡ªåŠ›ã§è§£ã‘ãŸã®ã§ã€è§£ãã‚¹ãƒ”ãƒ¼ãƒ‰ãŒã‚‚ã£ã¨å¿…è¦ã ãªã¨æ„Ÿã˜ã¾ã—ãŸã€‚Eå•é¡Œã«é–¢ã—ã¦ã¯ã€è¦‹ãŸæ„Ÿã˜è§£ã‘ãã†ã ã£ãŸã®ã§ã€ã‚³ãƒ³ãƒ†ã‚¹ãƒˆç¿Œæ—¥è§£ã„ã¦ã¿ãŸã‚‰ã€è‡ªåŠ›ã§è§£ãã“ã¨ãŒã§ãã¾ã—ãŸã€‚

ä»¥ä¸‹ã€A-Eã®å•é¡Œã«ã¤ã„ã¦æ·±å €ã‚Šã‚’ã—ã¦ã¿ãŸã®ã§ã€å…±æœ‰ã—ã¾ã™ã€‚æ·±å €ã‚ŠãŒæµ…ã„ç®‡æ‰€ã‚‚ã‚ã‚‹ã‹ã¨æ€ã„ã¾ã™ãŒã€‚ã€‚ã€‚
ãƒã‚¿ãƒãƒ¬ã«ãªã‚Šã¾ã™ã®ã§ã€è‡ªåˆ†ã§è§£ã„ã¦ã¿ãŸã„äººã¯ä»¥ä¸‹ã§è§£ã„ãŸå¾Œã€èª­ã‚“ã§é ‚ã‘ã‚Œã°ã¨æ€ã„ã¾ã™ã€‚ç­”ãˆã¯è¦‹ãŸããªã„ã‘ã©ã€ã¡ã‚‡ã£ã¨ãƒ’ãƒ³ãƒˆãŒã»ã—ã„äººå‘ã‘ã«ã€ãƒ’ãƒ³ãƒˆã‚’è¨˜è¼‰ã—ã¾ã—ãŸï¼ˆA, Bå•é¡Œã¯åŸºæœ¬å•é¡Œã§ã€ãƒ’ãƒ³ãƒˆã®æ›¸ãã‚ˆã†ãŒãªã„ã®ã§ã€ç„¡ã—ã§ï¼‰ã€‚
https://atcoder.jp/contests/abc276

# ãƒ’ãƒ³ãƒˆ

- A. ãƒ’ãƒ³ãƒˆãªã—
- B. ãƒ’ãƒ³ãƒˆãªã—
- C. å…¥å‡ºåŠ›ä¾‹ã®é•ã„ã‚’ã¿ã¦æ³•å‰‡æ€§ã‚’è¦‹ã¤ã‘ã¦ã¿ã¾ã—ã‚‡ã†ï¼
- D. [2, 2, 2]ã‚’å‰²ã‚Šã™ãã¦ã€[1, 1, 1]ã«ã—ãŸã‚‰ãƒ€ãƒ¡ï¼å‰²ã‚Šã™ããªã„ã‚ˆã†ã«ã™ã‚‹ã«ã¯ä½•ã‚’æ±‚ã‚ã‚‹ï¼Ÿ
- E. é“ã‚’é ‚ç‚¹ã¨ã—ãŸã‚°ãƒ©ãƒ•ã®å•é¡Œ

# A - Rightmost

æ–‡å­—åˆ—ã‚’å·¦ã‹ã‚‰é †ç•ªã«è¦‹ã¦ã„ãã€`a`ãªã‚‰ã€ãã®indexã‚’ä¿å­˜ã—ã¦ã„ã‘ã°è‰¯ã•ãã†ã§ã™ã€‚è¦‹ã¤ã‹ã‚‰ãªã‹ã£ãŸã‚‰-1ãªã®ã§ã€åˆæœŸå€¤ã¯-1ã¨ã—ã¦ã€ä¿å­˜ã™ã‚‹indexã¯`1 indexed`ã«ã™ã‚‹å¿…è¦ãŒã‚ã‚‹ã®ã§ã€+1ã—ã¾ã™ã€‚

```rust
use proconio::{
    fastout, input,
    marker::{Chars, Usize1},
};

#[derive(Default)]
struct Solver {}
impl Solver {
    #[fastout]
    fn solve(&mut self) {
        input! {
            S: Chars
        }

        let mut ans = -1_isize;
        for (i, &s) in S.iter().enumerate() {
            if s == 'a' {
                ans = i as isize + 1;
            }
        }
        println!("{}", ans);
    }
}
```

:::message
`main()`é–¢æ•°ã¯ä»¥ä¸‹ã®è¨˜äº‹ã‚’å‚è€ƒã«ã—ã¦ãã ã•ã„ã€‚
https://zenn.dev/tipstar0125/articles/f9c4626cdd4d5b
:::

Aå•é¡Œãªã®ã§ã€ã‚ã¾ã‚Šæ·±å €ã‚ˆã†ãŒãªã„ã®ã§ã™ãŒã€å³ã‹ã‚‰é€†é †ã«è¦‹ã¦ã„ã£ã¦ã€è¦‹ã¤ã‹ã£ãŸã‚‰ã€ãã®indexã‚’å‡ºåŠ›ã—ã¦ã€è¦‹ã¤ã‹ã‚‰ãªã‘ã‚Œã°ã€-1ã‚’å‡ºåŠ›ã™ã‚‹ã€ã¨ã„ã†æ–¹é‡ãŒç¬¬1æ„Ÿã®äººã‚‚ã„ã‚‹ã‹ã¨æ€ã„ã¾ã™ã€‚`enumerate`ã—ã¦ã‹ã‚‰`rev`ã™ã‚Œã°ã€æ–‡å­—åˆ—ã‚‚indexã‚‚é€†é †ã«ãªã‚‹ã®ã§ä¾¿åˆ©ã§ã™ã€‚

```rust
for (i, &s) in S.iter().enumerate().rev() {
    if s == 'a' {
        let ans = i as isize + 1;
        println!("{}", ans);
        return;
    }
}
println!("-1");
```

# B - Adjacency List

ã‚°ãƒ©ãƒ•ã®åŸºæœ¬å•é¡Œã§ã™ã­ã€‚`ç«¶æŠ€ãƒ—ãƒ­ã‚°ãƒ©ãƒŸãƒ³ã‚°ã®é‰„å‰‡`ã®ã‚°ãƒ©ãƒ•ã®å•é¡Œã§ä¸€ç•ªæœ€åˆã«ç¿’ã†éš£æ¥ãƒªã‚¹ãƒˆã‚’æ±‚ã‚ã‚‹å•é¡Œã§ã™ã€‚ã‚°ãƒ©ãƒ•ã®å•é¡Œã ã¨æœ€åˆã«éš£æ¥ãƒªã‚¹ãƒˆã‚’ä½œã£ã¦ã‹ã‚‰ã€è‰²ã€…å‡¦ç†ã‚’æ›¸ãã®ã§ã€åŸºæœ¬ã«ã—ã¦é‡è¦ãªæŠ€è¡“ã§ã™ã€‚ã“ã®å•é¡Œã¯éš£æ¥ãƒªã‚¹ãƒˆã‚’ä½œæˆã—ã¦ã€å‡ºåŠ›æ™‚ã«æ˜‡é †ã«ã‚½ãƒ¼ãƒˆã™ã‚Œã°è‰¯ã•ãã†ã§ã™ã€‚Rustã®å ´åˆã€`clone`ã—ã¦ã‹ã‚‰ã‚½ãƒ¼ãƒˆã™ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™ã€‚

```rust
use itertools::Itertools;
use proconio::{
    fastout, input,
    marker::{Chars, Usize1},
};

#[derive(Default)]
struct Solver {}
impl Solver {
    #[fastout]
    fn solve(&mut self) {
        input! {
            N:usize,
            M:usize,
            AB: [(usize, usize); M]
        }

        let mut G = vec![vec![]; N + 1];
        for &(a, b) in &AB {
            G[a].push(b);
            G[b].push(a);
        }

        for i in 1..=N {
            let mut gi = G[i].clone();
            gi.sort();
            println!("{} {}", gi.len(), gi.iter().join(" "))
        }
    }
}
```

Rustãªæ›¸ãæ–¹ã¨ã—ã¦ã€éš£æ¥ãƒªã‚¹ãƒˆã«`Vec`ã‚’ä½¿ç”¨ã™ã‚‹ã®ã§ã¯ãªãã€æ˜‡é †ã«ä¸¦ã‚“ã é›†åˆ`BTreeSet`ã‚’ä½¿ç”¨ã™ã‚‹ã¨ã€ã‚½ãƒ¼ãƒˆãŒè‡ªå‹•ã§ãªã•ã‚Œã‚‹ã®ã§ã€ãã®ã¾ã¾å‡ºåŠ›ã™ã‚‹ã“ã¨ã‚‚ã§ãã¾ã™ã€‚

```rust
use std::collections::BTreeSet;

let mut G = vec![BTreeSet::new(); N + 1];
for &(a, b) in &AB {
    G[a].insert(b);
    G[b].insert(a);
}

for i in 1..=N {
    println!("{} {}", G[i].len(), G[i].iter().join(" "))
}
```

# C - Previous Permutation

å•é¡Œã®é€šã‚Šã€1ã¤å‰ã®é †åˆ—ã‚’æ±‚ã‚ã‚‹å•é¡Œã§ã™ã€‚
ã‚³ãƒ³ãƒ†ã‚¹ãƒˆä¸­ã«ã€ä¸ãˆã‚‰ã‚Œã¦ã„ã‚‹é †åˆ—ã¨1ã¤å‰ã®é †åˆ—ã®é•ã„ã®æ³•å‰‡æ€§ã‚’è¦‹ã¤ã‘ã‚‹ã®ã«ã€ã¾ãã¾ãæ™‚é–“ã‚’è¦ã—ã¦ã—ã¾ã„ã¾ã—ãŸã€‚ã€‚ã€‚çŸ¥ã£ã¦ã„ãŸã‚‰ãã‚“ãªã«é›£ã—ãã¯ãªã„ã¨æ€ã„ã¾ã™ãŒã€ã‚³ãƒ³ãƒ†ã‚¹ãƒˆä¸­ã¯ã€Œã¯ï¼Ÿï¼Ÿã‚€ãšãã­ï¼Ÿï¼Ÿã€ã¨æ€ã£ã¦ã„ã¾ã—ãŸã€‚ã€‚ã€‚
æ³•å‰‡ã§ã™ãŒã€ä»¥ä¸‹ã®å…¥å‡ºåŠ›ä¾‹ã‚’å‚è€ƒã«èª¬æ˜ã—ã¾ã™ã€‚ä»¥ä¸‹ã®ãƒã‚¤ãƒ³ãƒˆã«æ°—ãŒä»˜ãã¨æ€ã„ã¾ã™ã€‚

- å‰åŠã®9 8 6 5 10ã¾ã§ã¯ å¤‰ã‚ã£ã¦ã„ãªã„
- inputã®å¾ŒåŠ1 2 4 7ã¯æ˜‡é †ã«ãªã£ã¦ã„ã‚‹
- inputã®å¾ŒåŠã®æ˜‡é †ã«ãªã£ã¦ã„ã‚‹ç®‡æ‰€ã®1ã¤å‰ã¯ã€å¾ŒåŠæ˜‡é †ã®ä¸­ã§1ã¤å°ã•ã„å€¤ã«å¤‰ã‚ã£ã¦ã„ã‚‹
- outputã®å¾ŒåŠ7 4 3 1ã¯é™é †ã«ãªã£ã¦ã„ã‚‹

```rust
9 8 6 5 10 3 1 2 4 7 // input
9 8 6 5 10 2 7 4 3 1 // output
```

ä»¥ä¸Šã®æ³•å‰‡ã‚’ã‚³ãƒ¼ãƒ‰ã«ã™ã‚Œã°è‰¯ã„ã§ã™ã€‚æµã‚Œã¨ã—ã¦ã¯ä»¥ä¸‹ã®é€šã‚Šã€‚
1. å¾Œã‚ã‹ã‚‰é †ç•ªã«æ•°å­—ã‚’æ¯”è¼ƒã—ã¦ã„ãã€æ˜‡é †ã«ãªã£ã¦ã„ãªã„indexã‚’æ¢ã™ã€‚ã“ã®ä¾‹ã§ã„ã†ã¨ã€3ã®index5ã¨ãªã‚Šã¾ã™ã€‚
2. index6ä»¥é™ã®ä¸­ã§ã€3ã‚ˆã‚Š1ã¤å°ã•ã„å€¤ã‚’æ¢ã™ã€‚
3. ä¸Šè¨˜ã§æ¢ã—ãŸå€¤ã¨3ã‚’ã‚¹ãƒ¯ãƒƒãƒ—ã—ã¾ã™ã€‚
4. ã‚¹ãƒ¯ãƒƒãƒ—å¾Œã€index6ä»¥é™ã‚’é™é †ã«ã‚½ãƒ¼ãƒˆã—ã¾ã™(ã‚¹ãƒ¯ãƒƒãƒ—ã—ãŸçŠ¶æ…‹ã§ã‚‚æ˜‡é †ã®çŠ¶æ…‹ã‚’ç¶­æŒã—ã¦ã„ã‚‹ã®ã§åè»¢ã™ã‚Œã°é™é †ã«ãªã‚Šã¾ã™)ã€‚

```rust
use itertools::Itertools;
use proconio::{
    fastout, input,
    marker::{Chars, Usize1},
};

#[derive(Default)]
struct Solver {}
impl Solver {
    #[fastout]
    fn solve(&mut self) {
        input! {
            N: usize,
            mut P: [usize; N]
        }
        // 1.
        let mut j = N - 2;
        while P[j] < P[j + 1] {
            j -= 1;
        }
        // 2.
        let mut k = N - 1;
        while P[j] < P[k] {
            k -= 1;
        }
        // 3.
        P.swap(j, k);
        // 4.
        let mut Q = vec![0; P.len() - j - 1];
        Q.clone_from_slice(&P[j + 1..]);
        Q.reverse();
        println!("{} {}", &P[..j + 1].iter().join(" "), Q.iter().join(" "));
    }
}
```

ä»¥ä¸Šãƒ©ã‚¤ãƒ–ãƒ©ãƒªã‚’çŸ¥ã‚‰ãªã„äººã®ã‚„ã‚Šæ–¹ã§ã™ã€‚`prev_permutation`ã‚’ä½¿ç”¨ã™ã¨ã€ç°¡å˜ã«æ›¸ãã“ã¨ãŒã§ãã¾ã™ã€‚ã¾ãŸã€1ã¤å¾Œã¨ã„ã†å•é¡Œã§ã‚ã£ãŸå ´åˆã¯ã€`next_permutation`ã¨ã„ã†ã®ã‚‚ã‚ã‚‹ã®ã§ã€ãã‚Œã‚’ä½¿ç”¨ã™ã‚Œã°è‰¯ã„ã ã‘ã§ã™ã€‚`prev_permutation`ã‚’ä½¿ç”¨ã™ã‚‹ã¨ã€å…ƒã®é †åˆ—ãŒã€1ã¤å‰ã®é †åˆ—ã«å¤‰æ›´ã•ã‚Œã¾ã™ï¼ˆãªã®ã§ã€`mut`ã¨ã™ã‚‹å¿…è¦ãŒã‚ã‚‹ï¼‰ã€‚æˆ»ã‚Šå€¤ã¯1ã¤å‰ã®é †åˆ—ãŒã‚ã‚Œã°ã€`true`ã§ã€ãªã‘ã‚Œã°`false`ã¨ãªã‚Šã¾ã™ï¼ˆä»Šå›ã¯1ã¤å‰ã®é †åˆ—ãŒã‚ã‚‹ã“ã¨ãŒä¿è¨¼ã•ã‚Œã¦ã„ã‚‹ã®ã§ä¸è¦ã§ã™ï¼‰ã€‚

```rust
use itertools::Itertools;
use proconio::{
    fastout, input,
    marker::{Chars, Usize1},
};
use superslice::Ext;

struct Solver {}
impl Solver {
    #[fastout]
    fn solve(&mut self) {
        input! {
            N: usize,
            mut P: [usize; N]
        }

        P.prev_permutation();
        println!("{}", P.iter().join(" "));
    }
}
```

# D - Divide by 2 or 3

ã“ã®å•é¡Œã‚’æœ€åˆã¿ãŸã¨ãã€2 or 3ã§å‰²ã‚Šåˆ‡ã‚ŒãŸã‚‰ã€å‰²ã£ã¦ã€ãã®å›æ•°ã‚’ã‚¤ãƒ³ã‚¯ãƒªãƒ¡ãƒ³ãƒˆã—ã€æœ€çµ‚çš„ãªå€¤ãŒå…¨ã¦ç­‰ã—ã‘ã‚Œã°ã€å›æ•°ã‚’å‡ºåŠ›ã€ç­‰ã—ããªã‘ã‚Œã°-1ã‚’å‡ºåŠ›ã™ã‚Œã°ã„ã„ã‚“ã˜ã‚ƒã­ï¼Ÿã¨æ€ã£ã¦ã€æ„æ°—æšã€…ã¨ä»¥ä¸‹ã®ã‚³ãƒ¼ãƒ‰ã‚’æ›¸ãã¾ã—ãŸã€‚çµæœ`WA`ã€‚ã€‚ã€‚æ•°åˆ†è€ƒãˆã¦ã€ä¾‹ãˆã°ã€[2, 2, 2]ãŒæœ€çµ‚çš„ãªç›®æ¨™ã ã¨ã™ã‚‹ã¨ã€[1, 1, 1]ã«ã—ã¦ä½™è¨ˆã«3å›å‰²ã£ãŸã‚‰ãƒ€ãƒ¡ã ã¨æ°—ãŒä»˜ãã¾ã—ãŸã€‚

```rust
input! {
    N: usize,
    a: [usize; N]
}
let mut b = vec![];
let mut ans = 0;

for &ai in &a {
    let mut c = ai;
    while d % 2 == 0 {
        c /= 2;
        ans += 1;
    }
    while d % 3 == 0 {
        c /= 3;
        ans += 1;
    }
    b.push(c);
}

for i in 0..N - 1 {
    if b[i] != b[i + 1] {
        is_ok = false;
    }
}

if is_ok {
    println!("{}", ans);
} else {
    println!("-1");
}
```

ã§ã¯ã€ã©ã†ã™ã‚‹ã‹ã€‚å‰²ã‚‹ã®ã¯æœ€å¤§å…¬ç´„æ•°ã¾ã§ã ãªã€ã¨æ°—ã¥ãã¾ã—ãŸã€‚ãŸã ã€ã‚³ãƒ³ãƒ†ã‚¹ãƒˆä¸­ã¯ã€3ã¤ä»¥ä¸Šã®æ•°ã®æœ€å¤§å…¬ç´„æ•°ã£ã¦ã©ã†ã‚„ã£ã¦æ±‚ã‚ã‚‹ã®ï¼Ÿã¨æ‚©ã‚“ã§ã€1ã¤ãšã¤ã‚„ã£ã¦ã„ã‘ã°ã„ã„ã ã‘ã ã‚ˆãªã€ã¨æ€ã„ãªãŒã‚‰ã‚‚ã€è‡ªä¿¡ãŒæŒã¦ãšã€ã‚°ã‚°ã£ãŸã‚Šã—ã¦ã„ã¾ã—ãŸã€‚ã€‚ã€‚è‰²ã€…è©¦è¡ŒéŒ¯èª¤ã—ã¦ã„ãŸã‚‰ã€ã‚³ãƒ³ãƒ†ã‚¹ãƒˆçµ‚äº†ã—ã€ãã®æ•°åˆ†å¾Œã«`AC`å–ã‚Œã‚‹ã¨ã„ã†ã€è‹¦ã„çµæœã«ãªã‚Šã¾ã—ãŸã€‚ã€‚ã€‚

```rust
let mut b = vec![];
let mut ans = 0;

let mut g = gcd(a[0], a[1]);
let mut is_ok = true;
for i in 2..N {
    g = gcd(g, a[i]);
}

for &ai in &a {
    let mut c = ai;
    let mut d = ai / g;
    while d % 2 == 0 {
        c /= 2;
        d /= 2;
        ans += 1;
    }
    while d % 3 == 0 {
        c /= 3;
        d /= 3;
        ans += 1;
    }
    b.push(c);
}

for i in 0..N - 1 {
    if b[i] != b[i + 1] {
        is_ok = false;
    }
}

if is_ok {
    println!("{}", ans);
} else {
    println!("-1");
}
```

ä¸Šè¿°ã®æ›¸ãæ–¹ã¯å°‘ã—ç„¡é§„ãŒã‚ã‚‹ã®ã§ã€ãƒªãƒ•ã‚¡ã‚¯ã‚¿ãƒªãƒ³ã‚°ã—ã¾ã™ã€‚
- æœ€å¤§å…¬ç´„æ•°ã¯åˆæœŸå€¤ã‚’0ã¨ã—ã¦ã€1ã¤ãšã¤é †ç•ªã«æ±‚ã‚ã¦ã„ã
- æœ€å¤§å…¬ç´„æ•°ã§å‰²ã£ã¦ã€ãã®å¾Œ2 or 3ã§å‰²ã‚Šç¶šã‘ã¦ã€æœ€çµ‚çš„ã«1ã«ãªã‚‰ãªã‘ã‚Œã°ã€ å…¨ã¦ç­‰ã—ããªã‚‰ãªã„ã®ã§ã€ãã®æ™‚ç‚¹ã§-1ã‚’å‡ºåŠ›ã—ã¦çµ‚äº†

```rust
let mut ans = 0;
let mut g = 0;
for i in 0..N {
    g = gcd(g, a[i]);
}

for &ai in &a {
    let mut c = ai / g;
    while c % 2 == 0 {
        c /= 2;
        ans += 1;
    }
    while c % 3 == 0 {
        c /= 3;
        ans += 1;
    }
    if c != 1 {
        println!("-1");
        return;
    }
}

println!("{}", ans);
```

# E - Round Trip

è¿·è·¯ç³»ã®å•é¡Œã¯ã€é“ã‚’ã‚°ãƒ©ãƒ•ã®é ‚ç‚¹ã¨è¦‹ãªã—ã¦ã€éš£æ¥ãƒªã‚¹ãƒˆã‚’ä½œæˆã™ã‚‹ã€ã‚°ãƒ©ãƒ•ã®å•é¡Œã¨ã¿ãªã›ãã†ã§ã™ã€‚å…¬å¼è§£ç­”ã‚’è¦‹ã‚‹é™ã‚Šã€å¹…å„ªå…ˆæ¢ç´¢ã¨ã‹UnionFindã¨ã‹è‰²ã€…ãªè§£ç­”ãŒã‚ã‚Šãã†ã§ã™ã€‚ç§ã¯æ·±ã•å„ªå…ˆæ¢ç´¢ã§ã€å†å¸°é–¢æ•°ä½¿ãˆã°ã€ã¡ã‚‡ã£ã¨ã‹ã£ã“ã‚ˆãã­ï¼Ÿã¨æ€ã£ãŸã®ã§ã€æ·±ã•å„ªå…ˆæ¢ç´¢ã§è§£ã„ã¦ã¿ã¾ã—ãŸã€‚çµæœã¨ã—ã¦ã¯ã€1ã¤`RE`(å®Ÿè¡Œã‚¨ãƒ©ãƒ¼)ãŒå‡ºã¦ã—ã¾ã„ã¾ã—ãŸã€‚è‰²ã€…èª¿æŸ»ã—ã¦ã¿ã¾ã—ãŸãŒã€ã‚³ãƒ¼ãƒ‰ã¯å•é¡Œãªã•ãã†ã ã£ãŸã®ã§ã€`RE`ã«ãªã£ã¦ã„ã‚‹ç®‡æ‰€ã®ãƒ¡ãƒ¢ãƒªã‚’ã¿ã‚‹ã¨ä¸€ç•ªå¤§ãã„å€¤ã ã£ãŸã®ã§ã€å†å¸°é–¢æ•°ã«ã‚ˆã‚‹ã‚¹ã‚¿ãƒƒã‚¯ã‚ªãƒ¼ãƒãƒ¼ãƒ•ãƒ­ãƒ¼ã ãªæ€ã£ã¦ã€`main`é–¢æ•°å†…ã®`stack size`ã‚’å¢—ã‚„ã—ã¾ã—ãŸã€‚çµæœã€`AC`ã‚²ãƒƒãƒˆã—ã¾ã—ãŸã€‚çµè«–ã¨ã—ã¦ã€ç§ã®è§£ç­”ã¯ã‚¨ãƒ©ãƒ¼ã®ãƒªã‚¹ã‚¯ãŒé«˜ã„ã®ã§ã€ã‚ˆããªã„è§£ç­”ã‹ãªã¨æ€ã„ã¾ã—ãŸã€‚

ã‚³ãƒ¼ãƒ‰ã®æµã‚Œã¯ä»¥ä¸‹ã®é€šã‚Šã§ã™ã€‚
1. ã‚¹ã‚¿ãƒ¼ãƒˆä½ç½®ã®é ‚ç‚¹ã‚’æ¢ç´¢
2. 'S' or '.'ã‚’é ‚ç‚¹ã¨ã™ã‚‹éš£æ¥ãƒªã‚¹ãƒˆã‚’ä½œæˆ
3. å†å¸°é–¢æ•°ã§æ·±ã•å„ªå…ˆæ¢ç´¢ï¼ˆæ—¢ã«è¨ªã‚ŒãŸé ‚ç‚¹ã¯æ¢ç´¢ã—ãªã„ã‚ˆã†ã«å†å¸°ãƒ¡ãƒ¢ã‚’ç”¨æ„ï¼‰
4. æ·±ã•ãŒ1ã‚ˆã‚Šå¤§ããã¦ã€ã‚¹ã‚¿ãƒ¼ãƒˆåœ°ç‚¹ã«æˆ»ã£ã¦ããŸã‚‰ã€is_okã‚’trueã«ã™ã‚‹


```rust
use proconio::{
    fastout, input,
    marker::{Chars, Usize1},
};

#[derive(Default)]
struct Solver {}
impl Solver {
    #[fastout]
    fn solve(&mut self) {
        input! {
            H: usize,
            W: usize,
            C: [Chars; H]
        }

        let mut G = vec![vec![]; H * W];
        let mut start = 0;
        // 1.
        for i in 0..H {
            for j in 0..W {
                if C[i][j] == 'S' {
                    start = i * W + j;
                }
            }
        }
        // 2.
        for i in 0..H {
            for j in 0..W - 1 {
                if (C[i][j] == '.' || C[i][j] == 'S') && (C[i][j + 1] == '.' || C[i][j + 1] == 'S')
                {
                    let index1 = i * W + j;
                    let index2 = i * W + j + 1;
                    G[index1].push(index2);
                    G[index2].push(index1);
                }
            }
        }
        for j in 0..W {
            for i in 0..H - 1 {
                if (C[i][j] == '.' || C[i][j] == 'S') && (C[i + 1][j] == '.' || C[i + 1][j] == 'S')
                {
                    let index1 = i * W + j;
                    let index2 = (i + 1) * W + j;
                    G[index1].push(index2);
                    G[index2].push(index1);
                }
            }
        }
        // 3.
        let mut visited = vec![false; H * W];
        let mut is_ok = false;
        dfs(start, &G, &mut visited, 0, start, &mut is_ok);

        if is_ok {
            println!("Yes");
        } else {
            println!("No");
        }
    }
}

fn main() {
    std::thread::Builder::new()
        .stack_size(128 * 1024 * 1024) // 64 * 1024 * 1024 ã ã¨RE
        .spawn(|| Solver::default().solve())
        .unwrap()
        .join()
        .unwrap();
}

fn dfs(
    pos: usize,
    G: &Vec<Vec<usize>>,
    visited: &mut Vec<bool>,
    depth: usize,
    end: usize,
    is_ok: &mut bool,
) {
    visited[pos] = true;
    for &next in &G[pos] {
        // 4.
        if next == end && depth > 1 {
            *is_ok = true;
        }
        if !visited[next] {
            dfs(next, G, visited, depth + 1, end, is_ok);
        }
    }
}

```

å¹…å„ªå…ˆæ¢ç´¢ã®è§£ç­”ä¾‹ã§ã™ã€‚ã‚³ãƒ¼ãƒ‰ã®æµã‚Œã¯ä»¥ä¸‹ã®é€šã‚Šã§ã™ã€‚
1. ã‚¹ã‚¿ãƒ¼ãƒˆä½ç½®ã®é ‚ç‚¹ã‚’æ¢ç´¢
2. 'S' or '.'ã‚’é ‚ç‚¹ã¨ã™ã‚‹éš£æ¥ãƒªã‚¹ãƒˆã‚’ä½œæˆ
3. ã‚¹ã‚¿ãƒ¼ãƒˆä½ç½®ã«éš£æ¥ã—ã¦ã„ã‚‹é ‚ç‚¹ã‚’ã‚­ãƒ¥ãƒ¼ã«è¿½åŠ ã—ã€é“ã®åå‰ã¨ã—ã¦ç•°ãªã‚‹æ•°å­—ã‚’å‰²ã‚ŠæŒ¯ã‚‹ï¼ˆã¾ã è¨ªã‚Œã¦ã„ãªã„ç®‡æ‰€ã¯-1ã€ã‚¹ã‚¿ãƒ¼ãƒˆã¯0ã¨ã™ã‚‹ã®ã§ã€ãã‚Œä»¥å¤–ã§è¨­å®šï¼‰ã€‚
4. ã‚­ãƒ¥ãƒ¼ãŒãªããªã‚‹ã¾ã§å¹…å„ªå…ˆæ¢ç´¢
5. è¨ªã‚Œã¦ã„ãªã„ç®‡æ‰€ã¯é“ã®åå‰ã‚’ä¿å­˜ã€ã‚¹ã‚¿ãƒƒã‚¯ã«è¿½åŠ ã—ã€è¨ªã‚Œã¦ã„ã‚‹ç®‡æ‰€ã§é“ã®åå‰ãŒç•°ãªã‚‹å ´åˆã¯é–‰è·¯ï¼ˆãŸã ã—ã€ã‚¹ã‚¿ãƒ¼ãƒˆã®0ä»¥å¤–ï¼‰

```rust
use std::collections::VecDeque;

use proconio::{
    fastout, input,
    marker::{Chars, Usize1},
};

#[derive(Default)]
struct Solver {}
impl Solver {
    #[fastout]
    fn solve(&mut self) {
        input! {
            H: usize,
            W: usize,
            C: [Chars; H]
        }

        let mut G = vec![vec![]; H * W];
        let mut start = 0;
        // 1.
        for i in 0..H {
            for j in 0..W {
                if C[i][j] == 'S' {
                    start = i * W + j;
                }
            }
        }
        // 2.
        for i in 0..H {
            for j in 0..W - 1 {
                if (C[i][j] == '.' || C[i][j] == 'S') && (C[i][j + 1] == '.' || C[i][j + 1] == 'S')
                {
                    let index1 = i * W + j;
                    let index2 = i * W + j + 1;
                    G[index1].push(index2);
                    G[index2].push(index1);
                }
            }
        }
        for j in 0..W {
            for i in 0..H - 1 {
                if (C[i][j] == '.' || C[i][j] == 'S') && (C[i + 1][j] == '.' || C[i + 1][j] == 'S')
                {
                    let index1 = i * W + j;
                    let index2 = (i + 1) * W + j;
                    G[index1].push(index2);
                    G[index2].push(index1);
                }
            }
        }

        let mut visited = vec![-1; H * W];
        let mut is_ok = false;
        let mut Q = VecDeque::new();
        // 3.
        visited[start] = 0;
        for (i, &x) in G[start].iter().enumerate() {
            visited[x] = i as isize + 1;
            Q.push_back(x);
        }
        // 4.
        while !Q.is_empty() {
            let pos = Q.pop_front().unwrap();
            for &n in &G[pos] {
                if visited[n] == -1 {
                    visited[n] = visited[pos];
                    Q.push_back(n);
                } else if visited[n] != 0 && visited[n] != visited[pos] { // 5.
                    is_ok = true;
                }
            }
        }

        if is_ok {
            println!("Yes");
        } else {
            println!("No");
        }
    }
}
```

UnionFindã®è§£ç­”ä¾‹ã§ã™ã€‚ã‚³ãƒ¼ãƒ‰ã®æµã‚Œã¯ä»¥ä¸‹ã®é€šã‚Šã§ã™ã€‚
1. '.'ã‚’é ‚ç‚¹ã¨ã™ã‚‹éš£æ¥ãƒªã‚¹ãƒˆã¨Sã«éš£æ¥ã—ã¦ã„ã‚‹é ‚ç‚¹ã®ãƒªã‚¹ãƒˆã‚’ä½œæˆ
2. Sã«éš£æ¥ã—ã¦ã„ã‚‹é ‚ç‚¹ã®ãƒªã‚¹ãƒˆã¯é‡è¤‡ã—ã¦è¿½åŠ ã•ã‚Œã¦ã„ã‚‹ã®ã§ã€ãƒ¦ãƒ‹ãƒ¼ã‚¯ã«ã™ã‚‹
3. éš£æ¥ãƒªã‚¹ãƒˆã‹ã‚‰UnionFindã‚’ä½œæˆ
4. Sã«éš£æ¥ã—ã¦ã„ã‚‹é ‚ç‚¹ã®æ•°ãŒ1ä»¥ä¸‹ãªã‚‰ã°ã€é–‰è·¯ã¯ã§ããªã„ã®ã§ã€ãã®æ™‚ç‚¹ã§çµ‚äº†ã€‚
5. éš£æ¥ãƒªã‚¹ãƒˆã¯Sã‚’é™¤å¤–ã—ã¦ã„ã‚‹ã®ã§ã€Sã«éš£æ¥ã—ã¦ã„ã‚‹é ‚ç‚¹ãŒåŒã˜ã‚°ãƒ«ãƒ¼ãƒ—ã«ã„ã‚Œã°é–‰è·¯ã€‚

```rust
use proconio::{
    fastout, input,
    marker::{Chars, Usize1},
};

#[derive(Debug, Clone)]
struct UnionFind {
    parent: Vec<isize>,
    size: usize,
}

impl UnionFind {
    fn new(n: usize) -> Self {
        UnionFind {
            parent: vec![-1; n + 1],
            size: n,
        }
    }

    fn find(&mut self, x: usize) -> usize {
        if self.parent[x] < 0 {
            return x;
        }
        let root = self.find(self.parent[x] as usize);
        self.parent[x] = root as isize;
        root
    }

    fn unite(&mut self, x: usize, y: usize) {
        let root_x = self.find(x);
        let root_y = self.find(y);
        if root_x == root_y {
            return;
        }
        let size_x = -self.parent[root_x];
        let size_y = -self.parent[root_y];
        if size_x >= size_y {
            self.parent[root_x] -= size_y;
            self.parent[root_y] = root_x as isize;
        } else {
            self.parent[root_y] -= size_x;
            self.parent[root_x] = root_y as isize;
        }
        self.size -= 1;
    }

    fn is_same(&mut self, x: usize, y: usize) -> bool {
        self.find(x) == self.find(y)
    }

    fn is_root(&mut self, x: usize) -> bool {
        self.find(x) == x
    }

    fn get_union_size(&mut self, x: usize) -> usize {
        let root = self.find(x);
        -self.parent[root] as usize
    }

    fn get_size(&self) -> usize {
        self.size
    }
}

#[derive(Default)]
struct Solver {}
impl Solver {
    #[fastout]
    fn solve(&mut self) {
        input! {
            H: usize,
            W: usize,
            C: [Chars; H]
        }

        let mut G = vec![vec![]; H * W];
        let mut start_adjacency = vec![];
        // 1.
        for i in 0..H {
            for j in 0..W - 1 {
                if C[i][j] == '.' && C[i][j + 1] == '.' {
                    let index1 = i * W + j;
                    let index2 = i * W + j + 1;
                    G[index1].push(index2);
                    G[index2].push(index1);
                }
                if C[i][j] == '.' && C[i][j + 1] == 'S' {
                    start_adjacency.push(i * W + j);
                }
                if C[i][j] == 'S' && C[i][j + 1] == '.' {
                    start_adjacency.push(i * W + j + 1);
                }
            }
        }
        for j in 0..W {
            for i in 0..H - 1 {
                if C[i][j] == '.' && C[i + 1][j] == '.' {
                    let index1 = i * W + j;
                    let index2 = (i + 1) * W + j;
                    G[index1].push(index2);
                    G[index2].push(index1);
                }
                if C[i][j] == '.' && C[i + 1][j] == 'S' {
                    start_adjacency.push(i * W + j);
                }
                if C[i][j] == 'S' && C[i + 1][j] == '.' {
                    start_adjacency.push((i + 1) * W + j);
                }
            }
        }
        // 2.
        start_adjacency.dedup();
        // 3.
        let mut uf = UnionFind::new(H * W);
        for i in 0..H * W {
            for &x in &G[i] {
                uf.unite(i, x);
            }
        }
        // 4.
        if start_adjacency.len() < 2 {
            println!("No");
            return;
        }
        // 5.
        let mut is_ok = false;
        for i in 0..start_adjacency.len() {
            for j in i + 1..start_adjacency.len() {
                if uf.is_same(start_adjacency[i], start_adjacency[j]) {
                    is_ok = true;
                }
            }
        }
        
        if is_ok {
            println!("Yes");
        } else {
            println!("No");
        }
    }
}
```

# ã¾ã¨ã‚

ä»Šå›ç›®æ¨™ã«ã—ã¦ã„ãŸ4å®Œã¯é”æˆã§ãã¾ã›ã‚“ã§ã—ãŸãŒã€è‰²ã€…å­¦ã³ãŒã‚ã‚Šéå¸¸ã«è‰¯ã„çµŒé¨“ã«ãªã‚Šã¾ã—ãŸã€‚
å®Ÿéš›ã®è§£ç­”ã¯ä»¥ä¸‹ã®Githubã‚’å‚ç…§ãã ã•ã„ã€‚

https://github.com/TatsuyaYoke/atcoder/tree/master/abc276