---
title: "Rust ç«¶ãƒ—ãƒ­ AHCå‚åŠ ã®æº–å‚™ã—ã¦ã¿ãŸï¼ˆãƒãƒ¼ãƒˆã‚·ãƒ¼ãƒˆé›†ï¼‰"
emoji: ğŸƒ
type: "tech"
topics: ["rust", "AtCoder", "ç«¶ãƒ—ãƒ­"]
published: true
---

AtCoder Heuristic Contest (AHC)å‚åŠ ã«å‘ã‘ã¦ã€thunderæœ¬ã‚„é‰„å‰‡æœ¬ã‚’å­¦ç¿’ã™ã‚‹ã¨ãã«ã€ã‚¢ãƒ«ã‚´ã¨ã¯ç•°ãªã‚Šã€ãƒ’ãƒ¥ãƒ¼ãƒªã‚¹ãƒ†ã‚£ãƒƒã‚¯ç‰¹æœ‰ã§è©°ã¾ã£ãŸç®‡æ‰€ã«ã¤ã„ã¦ã€ãƒãƒ¼ãƒˆã‚·ãƒ¼ãƒˆé›†ã¨ã—ã¦å…±æœ‰ã—ã¾ã™ã€‚ã¾ã AHCå‚åŠ ã—ãŸã“ã¨ãŒãªãã€æ´—ç·´ã•ã‚Œã¦ã¯ã„ã¾ã›ã‚“ãŒã€å¼·ã€…ã®ä¸Šä½å‹¢ã®ã‚³ãƒ¼ãƒ‰ã‚’è‰¯ã„ã¨ã“å–ã‚Šã‚’ã—ã¦ã„ã¾ã™ã®ã§ã€ãã‚“ãªã«çš„å¤–ã‚Œã§ã¯ãªã„ã¨æ€ã„ã¾ã™ã€‚
é©å®œæ°—ã¥ããŒã‚ã‚Œã°ã€æ›´æ–°ãƒ»ä¿®æ­£ã—ã¦ã„ãäºˆå®šã§ã™ã€‚

# Time Keeper

AHCã§ã¯åˆ¶é™æ™‚é–“ã„ã£ã±ã„æ¢ç´¢ã™ã‚‹ã“ã¨ã‚’ã—ã¾ã™ã€‚ã‚„ã‚Šæ–¹ã¯è‰²ã€…ã‚ã‚‹ã®ã§ã™ãŒã€ã‚„ã‚Šæ–¹ã‚’é–“é•ã†ã¨å‡¦ç†ãŒé‡ããªã£ãŸã‚Šã™ã‚‹ã“ã¨ãŒã‚ã‚‹ã®ã§æ³¨æ„ãŒå¿…è¦ã§ã™ã€‚
ä»¥ä¸‹ã€2ã¤ã®ã‚„ã‚Šæ–¹ã‚’ç´¹ä»‹ã—ã¾ã™ã€‚å€‹äººçš„ã«ã¯æ§‹é€ ä½“ã§ä½œã‚‹æ–¹æ³•ã®æ–¹ãŒã€åˆ¶é™æ™‚é–“ã‚’è¤‡æ•°å›è¨­å®šã—ãŸã„å ´åˆã«ä½¿ã„ã‚„ã™ã„ã®ã§ã‚ªã‚¹ã‚¹ãƒ¡ã§ã™ã€‚

### æ§‹é€ ä½“ã§ä½œã‚‹æ–¹æ³•

ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã‚’ç”Ÿæˆã™ã‚‹ã¨ãã«ã€æ™‚é–“åˆ¶é™ã‚’è¨­å®šã—ã¦ã€ãã®ã¨ãã‹ã‚‰ã€æ™‚é–“åˆ¶é™ã‚’éããŸã¨ãã«ã€`isTimeOver`é–¢æ•°ã‚’å‘¼ã³å‡ºã™ã¨`true`ãŒè¿”ã£ã¦ãã¾ã™ã€‚ã‚‚ã¡ã‚ã‚“æ™‚é–“åˆ¶é™ä»¥å†…ã«å‘¼ã³å‡ºã™ã¨`false`ãŒè¿”ã£ã¦ãã¾ã™ã€‚

```rust
#[derive(Debug, Clone)]
struct TimeKeeper {
    start_time: Instant,
    time_threshold: f64,
}

impl TimeKeeper {
    fn new(ms: usize) -> Self {  // mså˜ä½ã§è¨­å®š
        TimeKeeper {
            start_time: Instant::now(),
            time_threshold: (ms * 1e3 as usize) as f64,
        }
    }
    #[inline]
    fn isTimeOver(&self) -> bool {
        let elapsed_time = self.start_time.elapsed().as_micros() as f64;
        #[cfg(feature = "local")]
        {
            elapsed_time * 0.85 >= self.time_threshold
        }
        #[cfg(not(feature = "local"))]
        {
            elapsed_time >= self.time_threshold
        }
    }
}
```

ä½¿ã„æ–¹ã¯ä»¥ä¸‹ã®é€šã‚Šã€‚ä»¥ä¸‹ã¯åˆ¶é™æ™‚é–“ã‚’980msã«è¨­å®šã—ã¦ã„ã¾ã™ã€‚

```rust
let time_keeper = TimeKeeper::new(980);
while !time_keeper.isTimeOver() {
    // å‡¦ç†
}
```

### é–¢æ•°ã§ä½œã‚‹æ–¹æ³•

é–¢æ•°ã‚’åˆå›å‘¼ã³å‡ºã—ãŸã¨ãã«`STIME`ãŒè¨­å®šã•ã‚Œã€ãã®ã¨ãã‹ã‚‰ã®çµŒéæ™‚é–“ï¼ˆå˜ä½ï¼šç§’ï¼‰ã‚’è¿”ã—ã¾ã™ã€‚

```rust
#[inline]
fn get_time() -> f64 {  // sec
    static mut STIME: f64 = -1.0;
    let t = std::time::SystemTime::now()
        .duration_since(std::time::UNIX_EPOCH)
        .unwrap();
    let ms = t.as_secs() as f64 + t.subsec_nanos() as f64 * 1e-9;
    unsafe {
        if STIME < 0.0 {
            STIME = ms;
        }
        #[cfg(feature = "local")]
        {
            (ms - STIME) * 0.85
        }
        #[cfg(not(feature = "local"))]
        {
            ms - STIME
        }
    }
}
```

ä½¿ã„æ–¹ã¯ä»¥ä¸‹ã®é€šã‚Šã€‚ä»¥ä¸‹ã¯åˆ¶é™æ™‚é–“ã‚’0.98ç§’ã«è¨­å®šã—ã¦ã„ã¾ã™ã€‚

```rust
get_time();
while get_time() < 0.98 {
    // å‡¦ç†
}
```

### feature = "local"

`feature = "local"`ã¯ã€ã‚¸ãƒ£ãƒƒã‚¸ã‚µãƒ¼ãƒã¨è‡ªåˆ†ã®PCã®å‡¦ç†é€Ÿåº¦ã‚’èª¿æ•´ã™ã‚‹ãŸã‚ã®è¨­å®šã§ã™ã€‚
ç‰¹ã«ä½•ã‚‚è¨­å®šã‚’ã—ã¦ã„ãªã‘ã‚Œã°ï¼ˆã‚¸ãƒ£ãƒƒã‚¸ã‚µãƒ¼ãƒã§ã¯ï¼‰ã€ä»¥ä¸‹ã®å‡¦ç†ãŒå®Ÿè¡Œã•ã‚Œã¾ã™ã€‚

```rust
#[cfg(not(feature = "local"))]
{
    // å‡¦ç†
}
```

`Cargo.toml`ã§è¨­å®šã‚’ã—ã¦ã€å®Ÿè¡Œæ™‚ã«ã‚³ãƒãƒ³ãƒ‰ã§æŒ‡å®šã™ã‚‹ã¨ã€ä»¥ä¸‹ã®å‡¦ç†ãŒå®Ÿè¡Œã•ã‚Œã¾ã™ã€‚

```rust
#[cfg(feature = "local")]
{
    // å‡¦ç†
}
```

- Cargo.toml

```
[features]
local = []
```

- ã‚³ãƒãƒ³ãƒ‰

```bash
cargo run --features local
```

- æ™‚é–“èª¿æ•´

ä¾‹ãˆã°ã€è‡ªåˆ†ã®PCã®å‡¦ç†é€Ÿåº¦ãŒã€ã‚¸ãƒ£ãƒƒã‚¸ã‚µãƒ¼ãƒã®0.85å€ã§ã€é…ã„å ´åˆã¯ä»¥ä¸‹ã®ã‚ˆã†ã«è¨­å®šã—ã¾ã™ã€‚

```rust
elapsed_time * 0.85 >= self.time_threshold
```

å‡¦ç†é€Ÿåº¦ã®æ¯”è¼ƒã§ã™ãŒã€ã‚‚ã£ã¨è‰¯ã„æ–¹æ³•ãŒã‚ã‚‹ã‹ã‚‚ã—ã‚Œã¾ã›ã‚“ãŒã€ç§ã¯ä»¥ä¸‹ã®æ–¹æ³•ã‚’å–ã‚Šã¾ã—ãŸã€‚ABCã§ã¯ã€ä»¥ä¸‹ã®ã‚ˆã†ã«å…¥å‡ºåŠ›æƒ…å ±ã‚’æä¾›ã—ã¦ã„ã‚‹ã‚‚ã®ãŒã‚ã‚Šã¾ã™ã€‚
ã“ã®ä¸­ã§æ¯”è¼ƒçš„ã€å…¥åŠ›ãŒå¤šãã€å®Ÿè¡Œæ™‚é–“ãŒé•·ã„ã‚‚ã®ã‚’é¸ã‚“ã§ã€å…¥åŠ›æƒ…å ±ã‚’ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰ã—ã€è‡ªåˆ†ã®ç’°å¢ƒã§ã®å®Ÿè¡Œæ™‚é–“ã‚’ä¸Šè¿°ã®`get_time()`é–¢æ•°ãªã©ã‚’ä½¿ã£ã¦æ¸¬å®šã€æ¯”è¼ƒã—ã¾ã™ã€‚

https://atcoder.jp/contests/abc194/submissions/41244712

å…¥åŠ›ã‚³ãƒ”ãƒšã§å…¥åŠ›ã™ã‚‹ã¨å…¥åŠ›ã«æ™‚é–“ãŒã‹ã‹ã‚‹ã®ã§ã€æ³¨æ„ã€‚
å®Ÿè¡Œã™ã‚‹éš›ã¯ã€åå‰ã‚’ä¾‹ãˆã°`in`ã¨ã—ã¦ã€ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆã®ãƒˆãƒƒãƒ—ã«ä¿å­˜ã—ãŸå¾Œã€ä»¥ä¸‹ã®ã‚³ãƒãƒ³ãƒ‰ã§å®Ÿè¡Œã§ãã¾ã™ã€‚

```bash
cargo run < in
```

# Randï¼ˆä¹±æ•°ï¼‰

### åŸºæœ¬

ä¹±æ•°ã¯åŸºæœ¬çš„ã«ã¯ã€ä»¥ä¸‹ã‚’ä½¿ç”¨ã™ã‚‹ã“ã¨ã§å•é¡Œã‚ã‚Šã¾ã›ã‚“ã€‚

```rust
use rand::Rng;

let mut rng = rand::thread_rng();
let r = rng.gen_range(0, 10); // 0-9
let r = rng.gen::<bool>(); // true or false
let r = rng.gen::<f64>(); // 0.0-1.0
```

ãƒ‡ãƒãƒƒã‚°ã™ã‚‹éš›ã«seedã‚’è¨­å®šã—ã¦ã€ä¹±æ•°ã‚’å›ºå®šã™ã‚‹å ´åˆã¯ä»¥ä¸‹ã‚’ä½¿ç”¨ã—ã¾ã™ã€‚

```rust
use rand::rngs::StdRng;
use rand::Rng;

let seed = 123;
let mut rng: rand::rngs::StdRng = rand::SeedableRng::seed_from_u64(seed);
let r = rng.gen_range(0, 10); // 0-9
let r = rng.gen::<bool>(); // true or false
let r = rng.gen::<f64>(); // 0.0-1.0
```

### ã‚·ãƒ¼ãƒ‰ã®ãƒ©ãƒ³ãƒ€ãƒ ã¨å›ºå®šã®åˆ‡ã‚Šæ›¿ãˆ

ãƒ‡ãƒãƒƒã‚°ã®éš›ã¯å›ºå®šã‚·ãƒ¼ãƒ‰ã§ã€ãƒ‡ãƒãƒƒã‚°ãŒå®Œäº†ã—ãŸã‚‰ã€ãƒ©ãƒ³ãƒ€ãƒ ã‚·ãƒ¼ãƒ‰ã§å‹•ä½œç¢ºèªã—ãŸã„ã®ã§ã€ç°¡å˜ã«ã‚·ãƒ¼ãƒ‰ã‚’åˆ‡ã‚Šæ›¿ãˆã‚‰ã‚Œã‚‹ã‚ˆã†ã«ã—ã¾ã™ã€‚
å‰é …ã¨åŒã˜ã‚ˆã†ã«ã€ä»¥ä¸‹ã®é€šã‚Š`feature`ã§è¨­å®šã—ã¾ã™ã€‚

```rust
#[allow(unused_mut, unused_assignments)]
let mut seed: usize = rand::thread_rng().gen();
// ä»¥ä¸‹ã§ã‚‚OKã ãŒã€ãƒ©ãƒ³ãƒ€ãƒ ã‚·ãƒ¼ãƒ‰ã§åŒã˜ã‚·ãƒ¼ãƒ‰ã‚’ä½¿ã„ã¾ã‚ã—ãŸã„å ´åˆã¯ä¸Šè¨˜ã‚’ä½¿ç”¨
// let mut seed = 0;
#[cfg(feature = "seed")]
{
    seed = 11216848234635351618;
}
```

- Cargo.toml

```
[features]
seed = []
```


- ã‚³ãƒãƒ³ãƒ‰

ã‚³ãƒãƒ³ãƒ‰ã¯ä»¥ä¸‹ã®é€šã‚Šã§ã™ã€‚æ™‚é–“èª¿æ•´ã®è¨­å®šã‚‚åŒæ™‚ã«ã™ã‚‹å ´åˆã¯ã€2è¡Œç›®ã®ã‚³ãƒãƒ³ãƒ‰ã§ã™ã€‚

```bash
cargo run --features seed
cargo run --features local --features seed
```

### ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«

ä¸Šè¿°ã®åŸºæœ¬ã®ã‚„ã‚Šæ–¹ã§åŸºæœ¬çš„ã«ã¯å•é¡Œãªã„ã®ã§ã™ãŒã€Rustã¯ã‚°ãƒ­ãƒ¼ãƒãƒ«å¤‰æ•°ãŒæ‰±ãˆãªã„ã®ã§ã€è‰²ã€…ãªé–¢æ•°ã§ä½¿ç”¨ã™ã‚‹å ´åˆã¯ã€å¼•æ•°åœ°ç„ã«ãªã£ã¦ã€å¤§å¤‰ã§ã™ã€‚ã¾ãŸã€ã‚ã–ã‚ã–ä¹±æ•°ã®ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã‚’ä½•å›ã‚‚ç”Ÿæˆã™ã‚‹ã‚‚ã®é¢å€’ã ã—ã€å‡¦ç†ãŒé‡ããªã‚Šãã†ã§æ°—æŒã¡ãŒè‰¯ãã‚ã‚Šã¾ã›ã‚“ã€‚
ã©ã®é–¢æ•°ã‹ã‚‰ã‚‚å‘¼ã³å‡ºã›ã‚‹ã‚ˆã†ã«ã€ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«åŒ–ã—ã¦ä½¿ç”¨ã—ã¾ã™ã€‚`init`é–¢æ•°ã§åˆæœŸåŒ–ã—ã¦ã€ç¨®ã€…ã®`gen`é–¢æ•°ã§ä¹±æ•°ã‚’è¿”ã—ã¾ã™ã€‚`init`é–¢æ•°ã§seedã‚’0ã«ã—ãŸã¨ãã¯ã€ãƒ©ãƒ³ãƒ€ãƒ ã§seedãŒè¨­å®šã•ã‚Œã€ãã‚Œä»¥å¤–ã ã¨å›ºå®šã®seedãŒè¨­å®šã•ã‚Œã¾ã™ã€‚

```rust
mod rnd {
    use rand::Rng;
    static mut S: usize = 0;
    static MAX: usize = 1e9 as usize;

    #[inline]
    pub fn init(seed: usize) {
        unsafe {
            if seed == 0 {
                S = rand::thread_rng().gen();
            } else {
                S = seed;
            }
        }
    }
    #[inline]
    pub fn gen() -> usize {
        unsafe {
            if S == 0 {
                init(0);
            }
            S ^= S << 7;
            S ^= S >> 9;
            S
        }
    }
    #[inline]
    pub fn gen_range(a: usize, b: usize) -> usize {
        gen() % (b - a) + a
    }
    #[inline]
    pub fn gen_bool() -> bool {
        gen() & 1 == 1
    }
    #[inline]
    pub fn gen_float() -> f64 {
        ((gen() % MAX) as f64) / MAX as f64
    }
}
```

ä½¿ã„æ–¹ã¯ä»¥ä¸‹ã®é€šã‚Šã€‚`init`ã‚’å®Ÿè¡Œã—ãŸé–¢æ•°ä»¥å¤–ã§ã‚‚ã€`init`ã‚’å®Ÿè¡Œã—ãŸçŠ¶æ…‹ã§å¼•ãç¶™ãŒã‚Œã€ä¹±æ•°ã‚’å–å¾—ã§ãã¾ã™ã€‚

```rust
#[allow(unused_mut, unused_assignments)]
let mut seed: usize = rand::thread_rng().gen();
// ä»¥ä¸‹ã§ã‚‚OKã ãŒã€ãƒ©ãƒ³ãƒ€ãƒ ã‚·ãƒ¼ãƒ‰ã§åŒã˜ã‚·ãƒ¼ãƒ‰ã‚’ä½¿ã„ã¾ã‚ã—ãŸã„å ´åˆã¯ä¸Šè¨˜ã‚’ä½¿ç”¨
// let mut seed = 0;
#[cfg(feature = "seed")]
{
    seed = 11216848234635351618;
}

rnd::init(seed);
let r = rnd::gen_range(0, 10); // 0-9
let r = rnd::gen_bool(); // true or false
let r = rnd::gen_float(); // 0.0-1.0
```

# æ¼”ç®—å­ã‚ªãƒ¼ãƒãƒ¼ãƒ­ãƒ¼ãƒ‰

ãƒ“ãƒ¼ãƒ ã‚µãƒ¼ãƒã‚’ä½¿ç”¨ã™ã‚‹ã¨ãã€æ§‹é€ ä½“ã‚’å„ªå…ˆã‚­ãƒ¥ãƒ¼ã«å…¥ã‚Œã‚‹ã¨ã„ã†å‡¦ç†ã‚’è¡Œã„ã¾ã™ãŒã€æ¯”è¼ƒæ¼”ç®—å­ã®ã‚ªãƒ¼ãƒãƒ¼ãƒ­ãƒ¼ãƒ‰ã‚’è¨­å®šã—ãªã„ã¨ã€æ§‹é€ ä½“åŒå£«ã®æ¯”è¼ƒãŒã§ããªã„ãŸã‚ã€å„ªå…ˆã‚­ãƒ¥ãƒ¼ã«å…¥ã‚Œã‚‹ã“ã¨ãŒã§ãã¾ã›ã‚“ã€‚ä»¥ä¸‹ã®é€šã‚Šæ¯”è¼ƒã®å®šç¾©ã‚’ã—ã¾ã™ã€‚`PartialEq`ã€`PartialOrd`ã€`Ord`ã®3ç‚¹ã‚»ãƒƒãƒˆã§å®šç¾©ã‚’ã—ã¾ã™ã€‚
`derive`ã®è¨­å®šå¿˜ã‚ŒãŒã¡ã§ã€ã‚¨ãƒ©ãƒ¼åœ°ç„ã«ãªã‚‹ã®ã§ã€æ³¨æ„ã—ã¾ã—ã‚‡ã†ã€‚ã¾ãŸã€ä»¥ä¸‹ã®ã‚ˆã†ã«ã€æ§‹é€ ä½“ã®ä¸­ã«ã•ã‚‰ã«ã‚«ã‚¹ã‚¿ãƒ ã®æ§‹é€ ä½“ã‚’ãƒ¡ãƒ³ãƒå¤‰æ•°ã¨ã—ã¦è¨­å®šã™ã‚‹å ´åˆã¯ã€æ¯”è¼ƒã®å®šç¾©ã¨é–¢ä¿‚ãªãã¦ã‚‚`derive`ã®è¨­å®šãŒå¿…è¦ã§ã™ã€‚
ä»¥ä¸‹ã®ä¾‹ã§ã¯ã€`score`ã¨ã„ã†å¤‰æ•°ã§æ¯”è¼ƒã‚’å®šç¾©ã—ã¦ã„ã¾ã™ã€‚`pos`ã¯å®šç¾©ã«ã¯é–¢ä¿‚ã—ã¾ã›ã‚“ãŒã€`Position`ã®å®šç¾©ã®éš›ã«`derive`è¨­å®šãŒå¿…è¦ã§ã™ã€‚

```rust
#[derive(Debug, Clone, Eq, PartialEq)]  // å¿˜ã‚ŒãŒã¡
struct Position {
    x: usize,
    y: usize,
}

impl Position {
    fn new() -> Self {
        Position { x: 0, y: 0 }
    }
}

#[derive(Debug, Clone, Eq)]  // å¿˜ã‚ŒãŒã¡
struct State {
    pos: Position,
    score: usize,
}

impl State {
    fn new() -> Self {
        State {
            pos: Position::new(),
            score: 0,
        }
    }
}

impl std::cmp::PartialEq for State {
    fn eq(&self, other: &Self) -> bool {
        self.score == other.score
    }
}

impl std::cmp::PartialOrd for State {
    fn partial_cmp(&self, other: &Self) -> Option<std::cmp::Ordering> {
        if self.score == other.score {
            Some(std::cmp::Ordering::Equal)
        } else if self.score > other.score {
            Some(std::cmp::Ordering::Greater)
        } else if self.score < other.score {
            Some(std::cmp::Ordering::Less)
        } else {
            None
        }
    }
}

impl std::cmp::Ord for State {
    fn cmp(&self, other: &Self) -> std::cmp::Ordering {
        if self.score == other.score {
            std::cmp::Ordering::Equal
        } else if self.score > other.score {
            std::cmp::Ordering::Greater
        } else {
            std::cmp::Ordering::Less
        }
    }
}
```

ä½¿ç”¨ã®ä»•æ–¹ã¯ä»¥ä¸‹ã®é€šã‚Šã§ã€å„ªå…ˆã‚­ãƒ¥ãƒ¼ã«å…¥ã‚Œã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚

```rust
let mut heap = BinaryHeap::new();
let mut state1 = State::new();
let mut state2 = State::new();
heap.push(state1);
heap.push(state2);
```

# ãã®ä»–

### å…¥åŠ›ã®ä¸€éƒ¨ã‚’ã‚°ãƒ­ãƒ¼ãƒãƒ«å¤‰æ•°

AHCã§ã¯ã€å…¥åŠ›ã®ä¸€éƒ¨ã‚‚è‰²ã‚“ãªé–¢æ•°ã§ä½¿ã„ã¾ã‚ã™ã“ã¨ãŒå¤šã„ã‚ˆã†ãªã®ã§ã€å…¥åŠ›ã®ä¸€éƒ¨ã‚‚ã‚°ãƒ­ãƒ¼ãƒãƒ«å¤‰æ•°ã«ã—ã¦ã€ã©ã“ã‹ã‚‰ã§ã‚‚å‘¼ã³å‡ºã›ã‚‹ã‚ˆã†ã«ã—ã¦ãŠãã¨ã€å¼•æ•°åœ°ç„ã‹ã‚‰é–‹æ”¾ã•ã‚Œã€å®Ÿè£…ãŒæ¥½ã«ãªã‚‹ã€‚å®Ÿè£…æ–¹æ³•ã¯ä»¥ä¸‹å‚ç…§ã€‚

https://zenn.dev/tipstar0125/articles/898cd37c76dce8#%E5%85%A5%E5%8A%9B%E3%81%AE%E4%B8%80%E9%83%A8%E3%82%92%E3%82%B0%E3%83%AD%E3%83%BC%E3%83%90%E3%83%AB%E5%A4%89%E6%95%B0

# ãŠã¾ã‘

thunderæœ¬ã€é‰„å‰‡æœ¬ã§ä¸Šè¨˜ã‚’ä½¿ç”¨ã—ãŸã‚³ãƒ¼ãƒ‰ã‚’Githubã«ãŠã„ã¦ã„ã‚‹ã®ã§ã€å‚è€ƒã«ã—ã¦ãã ã•ã„ã€‚

### thunderæœ¬

- 3ç« 

https://github.com/tipstar0125/thunder-book/blob/master/maze/src/main.rs

- 4ç« 

https://github.com/tipstar0125/thunder-book/blob/master/auto_move_maze/src/main.rs

### é‰„å‰‡æœ¬

- a46 (Heuristic 1)

https://github.com/tipstar0125/atcoder/blob/master/tessoku-book/src/bin/a46.rs