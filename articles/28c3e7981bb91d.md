---
title: "ã€AHCã€‘Rustã ã‘ã§ãƒ“ã‚¸ãƒ¥ã‚¢ãƒ©ã‚¤ã‚¶ã‚’ä½œã‚ã†ï¼(egui)"
emoji: "ğŸƒ"
type: "tech"
topics: ["rust", "AtCoder", "AHC"]
published: true
---

ã‚³ãƒ³ãƒ†ã‚¹ãƒˆä¸­ã«ã€æä¾›ã•ã‚Œã¦ã„ã‚‹ãƒ“ã‚¸ãƒ¥ã‚¢ãƒ©ã‚¤ã‚¶ã¨ã¯ç•°ãªã‚‹å¯è¦–åŒ–ã‚’ã—ãŸã„ã€ã‚³ãƒ¼ãƒ‰ã®ãƒ‡ãƒãƒƒã‚°ã‚’å¯è¦–åŒ–ã—ãªãŒã‚‰è¡Œã„ãŸã„ã€ãªã©è‡ªåˆ†å°‚ç”¨ã®ãƒ“ã‚¸ãƒ¥ã‚¢ãƒ©ã‚¤ã‚¶ãŒã»ã—ã„ãªã€ã¨æ€ã†ã“ã¨ãŒã‚ã‚Šã¾ã™ã€‚

ä»¥å‰ã€ãƒãƒ¼ãƒ æˆ¦ç”¨ã«è¨€èªãŒç•°ãªã‚‹ãƒãƒ¼ãƒ ãƒ¡ãƒ³ãƒãƒ¼ã¨ãƒ“ã‚¸ãƒ¥ã‚¢ãƒ©ã‚¤ã‚¶ã‚’å…±æœ‰ã™ã‚‹æ–¹æ³•ã«ã¤ã„ã¦æŠ•ç¨¿ã—ã¾ã—ãŸã€‚

https://zenn.dev/tipstar0125/articles/d2cf0ef63bceb7

ã“ã‚Œã‚’åˆ©ç”¨ã™ã‚‹ã®ã‚‚ã‚ã‚Šãªã®ã§ã™ãŒã€å€‹äººæˆ¦ã®å ´åˆã€ä»¥ä¸‹ã®ã‚ˆã†ãªå•é¡ŒãŒã‚ã‚‹ã®ã§ã€ãªã‚“ã¨ã‹Rustã ã‘ã§ãƒ“ã‚¸ãƒ¥ã‚¢ãƒ©ã‚¤ã‚¶ã‚’ä½œã‚ŠãŸã„ã€ã¨ã„ã†æ°—æŒã¡ã«ãªã‚Šã¾ã™ã€‚
- æå‡ºã‚³ãƒ¼ãƒ‰ã§æ›¸ã„ãŸæ§‹é€ ä½“ã‚„é–¢æ•°ã‚’ä½¿ã„å›ã—ãŸã„ã®ã§ã€æå‡ºã‚³ãƒ¼ãƒ‰ã¨åˆ†ã‘ãŸããªã„
- ãƒ–ãƒ©ã‚¦ã‚¶ä¸Šã®ãƒ“ã‚¸ãƒ¥ã‚¢ãƒ©ã‚¤ã‚¶ã«å…¥å‡ºåŠ›ã‚’ã‚ã–ã‚ã–ã‚³ãƒ”ãƒšã—ãŸããªã„


ãã“ã§ã€è‰²ã€…èª¿ã¹ã‚‹ã¨ã€`egui`ã¨ã„ã†crateã§ã‚ã‚Œã°ã€Rustã ã‘ã§ãƒ“ã‚¸ãƒ¥ã‚¢ãƒ©ã‚¤ã‚¶ã‚’ä½œã‚‹ã“ã¨ãŒã§ããã†ï¼ã€ã¨ã„ã†ã“ã¨ã§ä½œã£ã¦ã¿ã¾ã—ãŸã€‚

# è¨­å®š

## Cargo.toml

AtCoderã§ã¯`rustc`ã®ãƒãƒ¼ã‚¸ãƒ§ãƒ³ãŒ`1.70.0`ãªã®ã§ã€ã“ã®ãƒãƒ¼ã‚¸ãƒ§ãƒ³ã«å¯¾å¿œã—ã¦ã„ã¦ã€ã‹ã¤`proconio`ã¨å¹²æ¸‰ã—ãªã„ãƒãƒ¼ã‚¸ãƒ§ãƒ³ã®`0.19.0`ã‚’ä½¿ç”¨ã—ã¾ã™ã€‚
ã¾ãŸã€ãƒ­ãƒ¼ã‚«ãƒ«ç’°å¢ƒã§ã®ã¿ã€ãƒ“ã‚¸ãƒ¥ã‚¢ãƒ©ã‚¤ã‚ºã‚’è¡Œã„ã€æå‡ºæ™‚ã¯`CE`ã«ãªã‚‰ãªã„ã‚ˆã†ã«ã™ã‚‹ãŸã‚ã«ã€`features`ã‚’è¨­å®šã—ã¦ãŠãã¾ã™ã€‚

```toml
[dependencies]
eframe = "0.19.0"

[features]
vis = []
```

## ã‚³ãƒ¼ãƒ‰ã®è¨­å®š

ã‚³ãƒ¼ãƒ‰å†…ã§ãƒ“ã‚¸ãƒ¥ã‚¢ãƒ©ã‚¤ã‚¶ã«é–¢ã™ã‚‹ã‚³ãƒ¼ãƒ‰ï¼ˆæå‡ºã™ã‚‹ã¨`CE`ã«ãªã£ã¦ã—ã¾ã†ã‚³ãƒ¼ãƒ‰ï¼‰ã«é–¢ã—ã¦ã¯ã€ä»¥ä¸‹ã®é€šã‚Šã€ã‚³ãƒ¼ãƒ‰ã®ç›´å‰ã«`#[cfg(feature = "vis")]`ã‚’æ›¸ã„ã¦ãŠãå¿…è¦ãŒã‚ã‚Šã¾ã™ã€‚

```rust
fn main() {
    #[cfg(feature = "vis")]
    {
        // Something
    }
}

#[cfg(feature = "vis")]
mod visualizer {
    // Something
}


```

## å®Ÿè¡Œæ™‚ã®ã‚³ãƒãƒ³ãƒ‰è¨­å®š

ä»¥ä¸‹ã®ã‚ˆã†ã«`features`ãƒ•ãƒ©ã‚°ä»˜ãã§å®Ÿè¡Œã™ã‚‹ã¨ã€ãƒ­ãƒ¼ã‚«ãƒ«ç’°å¢ƒã§ã®ã¿ã€ãƒ“ã‚¸ãƒ¥ã‚¢ãƒ©ã‚¤ã‚¶ã‚’å®Ÿè¡Œã™ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚

```bash
cargo run -r --features vis
```


# ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆ

:::details ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆ

```rust
fn main() {

    // ã“ã“ã«æå‡ºã‚³ãƒ¼ãƒ‰ã‚’æ›¸ã

    // ãƒ“ã‚¸ãƒ¥ã‚¢ãƒ©ã‚¤ã‚¶ã¯æœ€å¾Œã«å®Ÿj
    let input = Input {};
    let output = Output {};
    let max_turn = 1000;
    #[cfg(feature = "vis")]
    {
        visualizer::vis(input, output, max_turn);
    }
}

pub struct Input {}
pub struct Output {}

#[cfg(feature = "vis")]
mod visualizer {
    use crate::{Input, Output};  // æå‡ºã‚³ãƒ¼ãƒ‰ã§ä½¿ç”¨ã™ã‚‹å…¥å‡ºåŠ›æ§‹é€ ä½“
    use eframe::egui::{
        show_tooltip_at_pointer, widgets, Align2, CentralPanel, Color32, Context, FontFamily,
        FontId, Id, Key, Pos2, Rect, RichText, Slider, Stroke, TextEdit, Ui,
    };
    use eframe::{run_native, App, CreationContext, Frame, NativeOptions, Storage, Theme};
    use std::time::{Duration, Instant};

    // ç”»é¢ã‚µã‚¤ã‚ºè¨­å®š
    const WIDTH: f32 = 800.0;
    const HEIGHT: f32 = 800.0;
    // ãƒ“ã‚¸ãƒ¥ã‚¢ãƒ©ã‚¤ã‚ºã‚µã‚¤ã‚ºè¨­å®š
    const VIS_WIDTH: f32 = 600.0;
    const VIS_HEIGHT: f32 = 600.0;
    // ãƒ“ã‚¸ãƒ¥ã‚¢ãƒ©ã‚¤ã‚ºå§‹ç‚¹ã®ã‚ªãƒ•ã‚»ãƒƒãƒˆ
    // ç”»é¢ä¸Šå´ã«ã¯ã‚¹ã‚³ã‚¢è¡¨ç¤ºã‚„æ“ä½œç”¨ã®ã‚¹ãƒ©ã‚¤ãƒ€ãƒ¼ã€ãƒã‚§ãƒƒã‚¯ãƒœãƒƒã‚¯ã‚¹ã‚’
    // ãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆã™ã‚‹ã®ã§ã€ãã®åˆ†ã‚’ç©ºã‘ã¦ãŠãï¼‰
    const OFFSET_WIDTH: f32 = (WIDTH - VIS_WIDTH) / 2.0;
    const OFFSET_HEIGHT: f32 = (HEIGHT - VIS_HEIGHT) / 2.0;
    // è‡ªå‹•å†ç”Ÿæ™‚ã®ã‚¹ãƒ”ãƒ¼ãƒ‰ã®ä¸Šé™ãƒ»ä¸‹é™
    const SPEED_MIN: usize = 1;
    const SPEED_MAX: usize = 10;

    pub struct Egui {
        input: Input,
        output: Output,
        turn: usize,
        max_turn: usize,
        checked: bool,
        play: bool,
        speed: usize,
        instant: Instant,
        cnt: usize,
    }

    impl Egui {
        fn new(input: Input, output: Output, max_turn: usize) -> Self {
            Egui {
                input,
                output,
                turn: max_turn,
                max_turn,
                checked: true,
                play: false,
                speed: 5,
                instant: Instant::now(),
                cnt: 0,
            }
        }
    }

    impl App for Egui {
        fn save(&mut self, _storage: &mut dyn Storage) {}
        fn update(&mut self, ctx: &Context, _frame: &mut Frame) {
            // è‡ªå‹•å†ç”Ÿç”¨ã®è¨­å®š
            // 5msæ¯ã«updateã‚’å¼·åˆ¶çš„ã«å‘¼ã³å‡ºã—ã¦ã€10msä»¥ä¸ŠçµŒéã—ãŸã‚‰ã‚«ã‚¦ãƒ³ãƒˆã‚¢ãƒƒãƒ—
            // ã‚¹ãƒ”ãƒ¼ãƒ‰è¨­å®šã«å¿œã˜ã¦ã€turnã‚’ã‚«ã‚¦ãƒ³ãƒˆã‚¢ãƒƒãƒ—
            ctx.request_repaint_after(Duration::from_millis(5));
            if self.instant.elapsed() >= Duration::from_millis(10) {
                self.cnt += 1;
                if self.cnt % (SPEED_MIN + SPEED_MAX - self.speed) == 0
                    && self.play
                    && self.turn < self.max_turn
                {
                    self.turn += 1;
                }
                self.instant = Instant::now();
            }

            CentralPanel::default().show(ctx, |ui| {
                // ã“ã“ã«ãƒ“ã‚¸ãƒ¥ã‚¢ãƒ©ã‚¤ã‚¶ã®ã‚³ãƒ¼ãƒ‰ã‚’æ›¸ã
            });
        }
    }

    pub fn vis(input: Input, output: Output, max_turn: usize) {
        let options = NativeOptions {
            initial_window_size: Some((WIDTH, HEIGHT).into()),  // ç”»é¢ã‚µã‚¤ã‚ºè¨­å®š
            initial_window_pos: Some(Pos2 { x: 100.0, y: 100.0 }),  // åˆæœŸä½ç½®è¨­å®š
            resizable: false,
            default_theme: Theme::Light,  // ãƒ©ã‚¤ãƒˆãƒ¢ãƒ¼ãƒ‰ or ãƒ€ãƒ¼ã‚¯ãƒ¢ãƒ¼ãƒ‰ã®ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆè¨­å®š
            ..NativeOptions::default()
        };
        let gui = Egui::new(input, output, max_turn);
        run_native("visualizer", options, Box::new(|_cc| Box::new(gui)));
    }
}
```
:::

# ãƒ“ã‚¸ãƒ¥ã‚¢ãƒ©ã‚¤ã‚º

## Rectangle

å››è§’å½¢ã‚’æç”»ã™ã‚‹å ´åˆã¯ã€ä»¥ä¸‹ã®é–¢æ•°ã‚’ç”¨ã„ã¾ã™ã€‚

```rust
pub fn rect(
    ui: &mut Ui,
    mut pos1: Pos2,  // å·¦ä¸Šã®åº§æ¨™
    mut pos2: Pos2,  // å³ä¸‹ã®åº§æ¨™
    fill_color: Color32,  // å¡—ã‚Šã¤ã¶ã—ã®è‰²
    stroke_color: Color32,  // æ ç·šã®è‰²
) -> Rect {
    // ã‚ªãƒ•ã‚»ãƒƒãƒˆåˆ†ãšã‚‰ã™
    pos1.x += OFFSET_WIDTH;
    pos2.x += OFFSET_WIDTH;
    pos1.y += OFFSET_HEIGHT;
    pos2.y += OFFSET_HEIGHT;

    let rect = Rect {
        min: pos1,
        max: pos2,
    };
    let rounding = 0.0;
    let stroke = Stroke {
        width: 0.2,
        color: stroke_color,
    };
    ui.painter().rect(rect, rounding, fill_color, stroke);
    rect
}
```

ä½¿ç”¨ä¾‹ã¯ä»¥ä¸‹ã®é€šã‚Šã€‚

:::details å››è§’å½¢æç”»ä¾‹

```rust
let N = 10;
let d = VIS_WIDTH / N as f32;

CentralPanel::default().show(ctx, |ui| {
    for i in 0..N {
        for j in 0..N {
            let pos1 = Pos2 {
                y: i as f32 * d,
                x: j as f32 * d,
            };
            let pos2 = Pos2 {
                y: pos1.y + d,
                x: pos1.x + d,
            };
            if (i + j) % 2 == 0 {
                rect(ui, pos1, pos2, Color32::RED, Color32::WHITE);
            } else {
                rect(ui, pos1, pos2, Color32::BLUE, Color32::WHITE);
            }
        }
    }
});
```
:::

![Document](/images/egui/Rectangle.png)

## Circle

å††ã‚’æç”»ã™ã‚‹å ´åˆã¯ã€ä»¥ä¸‹ã®é–¢æ•°ã‚’ç”¨ã„ã¾ã™ã€‚

```rust
pub fn circle(
    ui: &mut Ui,
    mut center: Pos2,  // ä¸­å¿ƒåº§æ¨™
    radius: f32,  // åŠå¾„
    fill_color: Color32,  // å¡—ã‚Šã¤ã¶ã—ã®è‰²
    stroke_color: Color32,  // æ ç·šã®è‰²
) {
    // ã‚ªãƒ•ã‚»ãƒƒãƒˆåˆ†ãšã‚‰ã™
    center.x += OFFSET_WIDTH;
    center.y += OFFSET_HEIGHT;
    let stroke = Stroke {
        width: 0.2,
        color: stroke_color,
    };
    ui.painter().circle(center, radius, fill_color, stroke);
}
```

ä½¿ç”¨ä¾‹ã¯ä»¥ä¸‹ã®é€šã‚Šã€‚

:::details å††æç”»ä¾‹
```rust
let N = 10;
let d = VIS_WIDTH / N as f32;

CentralPanel::default().show(ctx, |ui| {
    for i in 0..N {
        for j in 0..N {
            let pos1 = Pos2 {
                y: i as f32 * d,
                x: j as f32 * d,
            };
            let pos2 = Pos2 {
                y: pos1.y + d,
                x: pos1.x + d,
            };
            let center = Pos2 {
                y: i as f32 * d + d / 2.0,
                x: j as f32 * d + d / 2.0,
            };
            if (i + j) % 2 == 0 {
                rect(ui, pos1, pos2, Color32::WHITE, Color32::BLACK);
                circle(ui, center, d / 3.0, Color32::BLUE, Color32::WHITE);
            } else {
                rect(ui, pos1, pos2, Color32::WHITE, Color32::BLACK);
                circle(ui, center, d / 3.0, Color32::RED, Color32::WHITE);
            }
        }
    }
});
```
:::

![Document](/images/egui/Circle.png)

## Line

ç·šã‚’æç”»ã™ã‚‹å ´åˆã¯ã€ä»¥ä¸‹ã®é–¢æ•°ã‚’ç”¨ã„ã¾ã™ã€‚

```rust
pub fn line(ui: &mut Ui, mut pos1: Pos2, mut pos2: Pos2, color: Color32) {
    pos1.x += OFFSET_WIDTH;
    pos2.x += OFFSET_WIDTH;
    pos1.y += OFFSET_HEIGHT;
    pos2.y += OFFSET_HEIGHT;
    let points = [pos1, pos2];
    let stroke = Stroke { width: 3.0, color };
    ui.painter().line_segment(points, stroke);
}
```

ä½¿ç”¨ä¾‹ã¯ä»¥ä¸‹ã®é€šã‚Šã€‚

:::details ç·šæç”»ä¾‹
```rust
let N = 10;
let d = VIS_WIDTH / N as f32;

CentralPanel::default().show(ctx, |ui| {
    for i in 0..N {
        for j in 0..N {
            let pos1 = Pos2 {
                y: i as f32 * d,
                x: j as f32 * d,
            };
            let pos2 = Pos2 {
                y: pos1.y + d,
                x: pos1.x + d,
            };
            if (i + j) % 2 == 0 {
                rect(ui, pos1, pos2, Color32::RED, Color32::WHITE);
            } else {
                rect(ui, pos1, pos2, Color32::BLUE, Color32::WHITE);
            }
        }
    }

    let roots = vec![(0, 0), (0, 2), (2, 4), (5, 4)];
    for nodes in roots.windows(2) {
        let (x1, y1) = nodes[0];
        let (x2, y2) = nodes[1];
        let pos1 = Pos2 {
            y: y1 as f32 * d + d / 2.0,
            x: x1 as f32 * d + d / 2.0,
        };
        let pos2 = Pos2 {
            y: y2 as f32 * d + d / 2.0,
            x: x2 as f32 * d + d / 2.0,
        };
        line(ui, pos1, pos2, Color32::WHITE);
    }
});
```
:::

![Document](/images/egui/Line.png)

ç ´ç·šã¯`0.27.2`ã®ãƒãƒ¼ã‚¸ãƒ§ãƒ³ã«å­˜åœ¨ã™ã‚‹ã‚ˆã†ã§ã™ãŒã€`0.19.0`ã«ã¯å­˜åœ¨ã—ãªã„ã‚ˆã†ãªã®ã§ã€è‡ªä½œã—ã¾ã—ãŸã€‚

:::details ç ´ç·š
```rust
pub fn dash_line(
    ui: &mut Ui,
    mut pos1: Pos2,
    mut pos2: Pos2,
    dash_length: f32,
    gap_length: f32,
    color: Color32,
) {
    pos1.x += OFFSET_WIDTH;
    pos2.x += OFFSET_WIDTH;
    pos1.y += OFFSET_HEIGHT;
    pos2.y += OFFSET_HEIGHT;

    let mut x1 = pos1.x;
    let mut y1 = pos1.y;
    let mut x2 = pos2.x;
    let mut y2 = pos2.y;
    let mut is_swap = false;
    if x1 == x2 {
        std::mem::swap(&mut x1, &mut y1);
        std::mem::swap(&mut x2, &mut y2);
        is_swap = true;
    }

    let a = (y2 - y1) / (x2 - x1);
    let b = y1 - a * x1;

    let f = |x: f32, target_length: f32| -> bool {
        let y = a * x + b;
        let len = ((x - x1).powf(2.0) + (y - y1).powf(2.0)).sqrt();
        len <= target_length
    };

    let mut positions = vec![];
    positions.push((x1, y1));
    let max_length = ((x1 - x2).powf(2.0) + (y1 - y2).powf(2.0)).sqrt();
    let mut cnt = 0;
    let mut target_length = 0.0f32;

    loop {
        if cnt % 2 == 0 {
            target_length += dash_length;
        } else {
            target_length += gap_length;
        }
        if target_length >= max_length {
            break;
        }

        let mut ok = x1;
        let mut ng = x2;
        while (ng - ok).abs() > 1e-3 {
            let m = (ok + ng) / 2.0;
            if f(m, target_length) {
                ok = m;
            } else {
                ng = m;
            }
        }

        positions.push((ok, a * ok + b));

        cnt += 1;
    }
    positions.push((x2, y2));
    if positions.len() % 2 == 1 {
        positions.pop();
    }
    if is_swap {
        for (a, b) in &mut positions {
            std::mem::swap(a, b);
        }
    }
    let mut i = 0;
    while i < positions.len() {
        let p1 = Pos2 {
            x: positions[i].0,
            y: positions[i].1,
        };
        let p2 = Pos2 {
            x: positions[i + 1].0,
            y: positions[i + 1].1,
        };
        line(ui, p1, p2, color);
        i += 2;
    }
}
```
:::

## Text

ãƒ†ã‚­ã‚¹ãƒˆã‚’æç”»ã™ã‚‹å ´åˆã¯ã€ä»¥ä¸‹ã®é–¢æ•°ã‚’ç”¨ã„ã¾ã™ã€‚

```rust
pub fn txt(ui: &mut Ui, txt: &str, mut pos: Pos2, size: f32, color: Color32) {
    pos.x += OFFSET_WIDTH;
    pos.y += OFFSET_HEIGHT;
    let anchor = Align2::CENTER_CENTER;
    let font_id = FontId::new(size, FontFamily::Monospace);
    ui.painter().text(pos, anchor, txt, font_id, color);
}
```

ä½¿ç”¨ä¾‹ã¯ä»¥ä¸‹ã®é€šã‚Šã€‚

:::details ãƒ†ã‚­ã‚¹ãƒˆæç”»ä¾‹
```rust
let N = 10;
let d = VIS_WIDTH / N as f32;

CentralPanel::default().show(ctx, |ui| {
    for i in 0..N {
        for j in 0..N {
            let pos1 = Pos2 {
                y: i as f32 * d,
                x: j as f32 * d,
            };
            let pos2 = Pos2 {
                y: pos1.y + d,
                x: pos1.x + d,
            };
            if (i + j) % 2 == 0 {
                rect(ui, pos1, pos2, Color32::RED, Color32::WHITE);
            } else {
                rect(ui, pos1, pos2, Color32::BLUE, Color32::WHITE);
            }
            let pos = Pos2 {
                y: i as f32 * d + d / 2.0,
                x: j as f32 * d + d / 2.0,
            };
            txt(ui, &(i * N + j).to_string(), pos, d / 3.0, Color32::BLACK);
        }
    }
});
```
:::

![Document](/images/egui/Text.png)

## Color

### RGB

å¯’è‰²ï½æš–è‰²ã‚’è¡¨ç¾ã™ã‚‹é–¢æ•°ã¯ä»¥ä¸‹ã®é€šã‚Šã§ã™ã€‚å¼•æ•°ã¯0.0ï½1.0ã®å€¤ã€‚

```rust
// 0 <= val <= 1
pub fn color32(mut val: f32) -> Color32 {
    val = val.min(1.0);
    val = val.max(0.0);
    let (r, g, b) = if val < 0.5 {
        let x = val * 2.0;
        (
            30. * (1.0 - x) + 144. * x,
            144. * (1.0 - x) + 255. * x,
            255. * (1.0 - x) + 30. * x,
        )
    } else {
        let x = val * 2.0 - 1.0;
        (
            144. * (1.0 - x) + 255. * x,
            255. * (1.0 - x) + 30. * x,
            30. * (1.0 - x) + 70. * x,
        )
    };
    Color32::from_rgb(r.round() as u8, g.round() as u8, b.round() as u8)
}
```

:::details RGBæç”»ä¾‹
```rust
let MAX = 50;
let d = 10.0;

CentralPanel::default().show(ctx, |ui| {
    for i in 0..=MAX {
        let pos1 = Pos2 {
            x: i as f32 * d,
            y: 0.0,
        };
        let pos2 = Pos2 {
            x: i as f32 * d + d,
            y: 4.0 * d,
        };
        rect(
            ui,
            pos1,
            pos2,
            color32(i as f32 / MAX as f32),
            Color32::TRANSPARENT,
        );
    }
});
```
:::

![Document](/images/egui/RGB.png)

### Opacity

é€æ˜åº¦ã‚’è¡¨ç¾ã™ã‚‹é–¢æ•°ã¯ä»¥ä¸‹ã®é€šã‚Šã§ã™ã€‚å¼•æ•°ã¯0.0ï½1.0ã®å€¤ã€‚

```rust
// 0 <= opacity <= 1
pub fn opacity(color: Color32, opacity: f32) -> Color32 {
    let opacity = (opacity * 255.0) as u8;
    Color32::from_rgba_premultiplied(color.r(), color.g(), color.b(), opacity)
}
```

:::details Opacityæç”»ä¾‹
```rust
let MAX = 50;
let d = 10.0;
let GREEN = Color32::from_rgb(0, 128, 0);

CentralPanel::default().show(ctx, |ui| {
    for i in 0..=MAX {
        let pos1 = Pos2 {
            x: i as f32 * d,
            y: 0.0,
        };
        let pos2 = Pos2 {
            x: i as f32 * d + d,
            y: 4.0 * d,
        };
        rect(
            ui,
            pos1,
            pos2,
            opacity(GREEN, i as f32 / MAX as f32),
            Color32::BLACK,
        );
    }
});
```
:::

![Document](/images/egui/Opacity.png)

# è¡¨ç¤ºãƒ»æ“ä½œ

## ã‚¹ã‚³ã‚¢è¡¨ç¤º

`label`ã‚’ç”¨ã„ã¦ã‚¹ã‚³ã‚¢è¡¨ç¤ºã‚’è¡Œã„ã¾ã™ã€‚æ–‡å­—ã‚µã‚¤ã‚ºã‚’å¤‰æ›´ã™ã‚‹å ´åˆã¯ã€`RichText`ã‚’ä½¿ç”¨ã—ã¾ã™ã€‚

```rust
let score = 1000;
CentralPanel::default().show(ctx, |ui| {
    ui.label(RichText::new(format!("Score: {}", score)).size(20.0));
});
```

![Document](/images/egui/score.png)

## ãƒã‚§ãƒƒã‚¯ãƒœãƒƒã‚¯ã‚¹

`checkbox`ã¯ä»¥ä¸‹ã®ã‚ˆã†ã«ä½¿ç”¨ã—ã¾ã™ã€‚`self.checked`ã¯`bool`ãªã®ã§ã€ã“ã®çŠ¶æ…‹ã«ã‚ˆã£ã¦ã€æç”»ã®æ–¹æ³•ã‚’å¤‰ãˆã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚

```rust
CentralPanel::default().show(ctx, |ui| {
    ui.checkbox(&mut self.checked, "Show Number");

    if self.checked {
        // Something
    }
});
```

![Document](/images/egui/checkbox.png)

## ã‚¹ãƒ©ã‚¤ãƒ€ãƒ¼

ã‚¿ãƒ¼ãƒ³ã®åˆ¶å¾¡ã‚„å†ç”Ÿã‚¹ãƒ”ãƒ¼ãƒ‰ã®åˆ¶å¾¡ã«ç”¨ã„ã‚‹ã‚¹ãƒ©ã‚¤ãƒ€ãƒ¼ã¯ä»¥ä¸‹ã®ã‚ˆã†ã«ã—ã¦è¡¨ç¤ºã™ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚

```rust
CentralPanel::default().show(ctx, |ui| {
    ui.horizontal(|ui| {
        ui.label(RichText::new("Turn: ").size(20.0));
        ui.add(Slider::new(&mut self.turn, 0..=self.max_turn));
    });
    ui.horizontal(|ui| {
        ui.label(RichText::new("Speed: ").size(20.0));
        ui.add(Slider::new(&mut self.speed, SPEED_MIN..=SPEED_MAX));
    });
});
```

![Document](/images/egui/slider.png)

## ã‚­ãƒ¼ãƒœãƒ¼ãƒ‰æ“ä½œ

å†ç”Ÿã‚¹ã‚¿ãƒ¼ãƒˆãƒ»ã‚¹ãƒˆãƒƒãƒ—ã€ã‚¿ãƒ¼ãƒ³ã‚’é€²ã‚ã‚‹ãƒ»æˆ»ã‚‹ãªã©ã®æ“ä½œã¯ä»¥ä¸‹ã®ã‚ˆã†ã«è¨­å®šã§ãã¾ã™ã€‚

```rust
// ã‚¹ãƒšãƒ¼ã‚¹ã‚­ãƒ¼ã§å†ç”Ÿã‚¹ã‚¿ãƒ¼ãƒˆãƒ»ã‚¹ãƒˆãƒƒãƒ—
if ctx.input().key_released(Key::Space) {
    self.play = !self.play;
};
// å³çŸ¢å°ã§ã‚¿ãƒ¼ãƒ³ã‚’é€²ã‚ã‚‹
if ctx.input().key_pressed(Key::ArrowRight) && self.turn < self.max_turn {
    self.turn += 1;
};
// å·¦çŸ¢å°ã§ã‚¿ãƒ¼ãƒ³ã‚’æˆ»ã‚‹
if ctx.input().key_pressed(Key::ArrowLeft) && self.turn > 0 {
    self.turn -= 1;
};
```

## Tooltip

ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã«ãƒ›ãƒãƒ¼ã—ãŸã¨ãã«ã€è©³ç´°æƒ…å ±ã‚’è¡¨ç¤ºã™ã‚‹æ©Ÿèƒ½ã¯ä»¥ä¸‹ã®ã‚ˆã†ã«å®Ÿè£…ã—ã¾ã™ã€‚
ã¾ãšã€`ui.input().pointer.hover_pos()`ã§ãƒã‚¤ãƒ³ã‚¿ã®ä½ç½®ã‚’å–å¾—ã—ã€ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®ç¯„å›²å†…ã§ã‚ã‚Œã°ã€`show_tooltip_at_pointer`ã‚’ç”¨ã„ã¦è¡¨ç¤ºã—ã¾ã™ã€‚
ä»¥ä¸‹ã®ä¾‹ã¯ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆãŒå››è§’å½¢ã®ä¾‹ã§ã™ãŒã€å††ã®å ´åˆãªã©ã¯ãƒ›ãƒãƒ¼ãŒåå¿œã™ã‚‹ç¯„å›²ã‚’å››è§’å½¢ã«è¿‘ä¼¼ã™ã‚‹ã®ãŒæ¥½ãªå®Ÿè£…ã‹ãªã¨æ€ã„ã¾ã™ã€‚

```rust
let N = 10;
let d = VIS_WIDTH / N as f32;

CentralPanel::default().show(ctx, |ui| {
    let hover_pos = ui.input().pointer.hover_pos();
    for i in 0..N {
        for j in 0..N {
            let pos1 = Pos2 {
                y: i as f32 * d,
                x: j as f32 * d,
            };
            let pos2 = Pos2 {
                y: pos1.y + d,
                x: pos1.x + d,
            };
            let rect = rect(ui, pos1, pos2, Color32::GRAY, Color32::WHITE);
            let pos = Pos2 {
                y: i as f32 * d + d / 2.0,
                x: j as f32 * d + d / 2.0,
            };
            txt(ui, &(i * N + j).to_string(), pos, d / 3.0, Color32::BLACK);
            if let Some(hover_pos) = hover_pos {
                if rect.contains(hover_pos) {
                    show_tooltip_at_pointer(ui.ctx(), Id::new("hover tooltip"), |ui| {
                        ui.label(format!("a[{}, {}] = {}", i, j, i * N + j));
                    });
                }
            }
        }
    }
});
```

![Document](/images/egui/tooltip.png)

## ãƒ©ã‚¤ãƒˆãƒ¢ãƒ¼ãƒ‰ãƒ»ãƒ€ãƒ¼ã‚¯ãƒ¢ãƒ¼ãƒ‰å¤‰æ›´

```rust
CentralPanel::default().show(ctx, |ui| {
    widgets::global_dark_light_mode_buttons(ui);
});
```

![Document](/images/egui/theme.png)

# å®Ÿè£…ä¾‹

ç¬¬ä¸€å›ãƒã‚¹ã‚¿ãƒ¼ã‚ºé¸æ‰‹æ¨©-äºˆé¸-ã®ãƒ“ã‚¸ãƒ¥ã‚¢ãƒ©ã‚¤ã‚¶ã‚’ä½œæˆã—ãŸã®ã§ã€ä»¥ä¸‹ã®æå‡ºã‚³ãƒ¼ãƒ‰ã‚’å‚è€ƒã«ã—ã¦ãã ã•ã„ã€‚

https://atcoder.jp/contests/masters-qual/submissions/52461616

![Document](/images/egui/vis.gif)