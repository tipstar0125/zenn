---
title: "ã€AHCã€‘Rustã§ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ãƒ•ã‚£ãƒ«ã‚¿æ›¸ã„ã¦ã¿ãŸ"
emoji: "ğŸƒ"
type: "tech"
topics: ["rust", "AtCoder"]
published: true
---

ç¬¬ä¸€å›ãƒã‚¹ã‚¿ãƒ¼ã‚ºã®æ±ºå‹ã§å‡ºé¡Œã•ã‚ŒãŸå•é¡Œã§ã€ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ãƒ•ã‚£ãƒ«ã‚¿ã¨ã„ã†ã‚‚ã®ã‚’ä½¿ã†ã£ã½ã„ã®ã§ã™ãŒã€ã‚ˆãåˆ†ã‹ã‚‰ãªã„ã®ã§ã€ãƒãƒƒãƒˆã‚’æ¼ã£ãŸã‚Šã€æœ¬å±‹ã§è‰²ã€…ç«‹ã¡èª­ã¿ã—ã¦ã„ãŸã‚‰ã€ã€è©³è§£ ç¢ºç‡ãƒ­ãƒœãƒ†ã‚£ã‚¯ã‚¹ Pythonã«ã‚ˆã‚‹åŸºç¤ã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ ã®å®Ÿè£…ã€ã¨ã„ã†æœ¬ãŒè‰¯ã•ãã†ã§ã—ãŸã€‚

https://www.amazon.co.jp/%E8%A9%B3%E8%A7%A3-%E7%A2%BA%E7%8E%87%E3%83%AD%E3%83%9C%E3%83%86%E3%82%A3%E3%82%AF%E3%82%B9-Python%E3%81%AB%E3%82%88%E3%82%8B%E5%9F%BA%E7%A4%8E%E3%82%A2%E3%83%AB%E3%82%B4%E3%83%AA%E3%82%BA%E3%83%A0%E3%81%AE%E5%AE%9F%E8%A3%85-KS%E7%90%86%E5%B7%A5%E5%AD%A6%E5%B0%82%E9%96%80%E6%9B%B8-%E4%B8%8A%E7%94%B0/dp/4065170060/ref=pd_lpo_sccl_2/358-3160576-5508222?pd_rd_w=dO8oS&content-id=amzn1.sym.855d8f70-df76-4181-80b0-56e48ae3bb9b&pf_rd_p=855d8f70-df76-4181-80b0-56e48ae3bb9b&pf_rd_r=GBJ5TMHNP81AS7Y56RFM&pd_rd_wg=g5XNl&pd_rd_r=59e28871-c10e-44c3-99f4-d08e81e849bb&pd_rd_i=4065170060&psc=1


YouTubeã§ã‚‚è§£èª¬ãŒã‚ã‚‹ã®ã§ã€ã–ã£ã¨æ—©é€ã‚Šã—ãªãŒã‚‰è¦‹ã‚‹ã¨ã€é›°å›²æ°—ãŒã¤ã‹ã‚ã¦ã‚ˆã‹ã£ãŸã§ã™ã€‚

https://www.youtube.com/watch?v=tlbeAu8yHEc&t=4s


æœ¬ã¯Pythonã§æ›¸ã‹ã‚Œã¦ã„ã‚‹ã®ã§ã™ãŒã€ç«¶ãƒ—ãƒ­ã§ã¯Rustã‚’ä½¿ç”¨ã—ã¦ã„ã‚‹ã—ã€ç†è§£ã‚’æ·±ã‚ã‚‹ãŸã‚ã«ã€Rustã§ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ãƒ•ã‚£ãƒ«ã‚¿ã«ã‚ˆã‚‹è‡ªå·±ä½ç½®æ¨å®šã‚’æ›¸ãã¾ã—ãŸã€‚

https://github.com/tipstar0125/robotics


# æ§‹æˆ

ãƒ•ã‚©ãƒ«ãƒ€æ§‹æˆã«é–¢ã—ã¦ã¯ä»¥ä¸‹ã®é€šã‚Šã§ã™ã€‚
`main`é–¢æ•°ã¯`a.rs`ã«è¨˜è¼‰ã—ã¦ãŠã‚Šã€ãã®ä»–ã¯`submit.rs`ã‚’é™¤ã„ã¦ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã§ã™ã€‚
ã“ã®ãƒœãƒªãƒ¥ãƒ¼ãƒ ã«ãªã‚‹ã¨ã•ã™ãŒã«å˜ä¸€ãƒ•ã‚¡ã‚¤ãƒ«ã§æ›¸ãã®ã¯ã—ã‚“ã©ã„ã®ã§ã€‚ã€‚ã€‚

```
.
|-- Cargo.lock       
|-- Cargo.toml       
|-- src
|   `-- bin
|       |-- a.rs     
|       |-- agent.rs 
|       |-- camera.rs
|       |-- common.rs
|       |-- estimator.rs
|       |-- motion.rs
|       |-- multivariate_normal.rs # not used
|       |-- normal.rs
|       |-- plot.rs # not used
|       |-- submit.rs # æå‡ºç”¨
|       `-- vis.rs
`-- submit.sh # æå‡ºç”¨
```


ä½¿ç”¨ã™ã‚‹ã‚¯ãƒ¬ãƒ¼ãƒˆã«é–¢ã—ã¦ã¯ã€ãƒ“ã‚¸ãƒ¥ã‚¢ãƒ©ã‚¤ã‚¶ã‚’é™¤ã„ã¦AtCoderã§ä½¿ç”¨ã§ãã‚‹ã‚‚ã®ã«é™å®šã—ã¦ã„ã¾ã™ã€‚

:::details Cargo.toml

```toml
[package]
name = "robotics"
version = "0.1.0"
edition = "2018"

# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html

[dependencies]
proconio = { version = "=0.4.5", features = ["derive"] }
rand = { version = "=0.8.5", features = ["small_rng", "min_const_gen"] }
getrandom = "=0.2.10"
rand_chacha = "=0.3.1"
rand_core = "=0.6.4"
rand_hc = "=0.3.2"
rand_pcg = "=0.3.1"
rand_distr = "=0.4.3"
eframe = "0.19.0"

[features]
local = []
```
:::


ä»Šå›æ›¸ã„ãŸã‚³ãƒ¼ãƒ‰ã¯ç‰¹ã«æå‡ºã™ã‚‹å¿…è¦ã¯ãªã„ã®ã§ã™ãŒã€AHCã«ãŠã„ã¦ã¯å˜ä¸€ãƒ•ã‚¡ã‚¤ãƒ«ã«ã¾ã¨ã‚ã¦æå‡ºã™ã‚‹å¿…è¦ãŒã‚ã‚‹ãŸã‚ã€ã¤ã„ã§ãªã®ã§å˜ä¸€ãƒ•ã‚¡ã‚¤ãƒ«ã«ãƒãƒ³ãƒ‰ãƒ«ã™ã‚‹ã‚¹ã‚¯ãƒªãƒ—ãƒˆ`submit.sh`ã¨æå‡ºãƒ•ã‚¡ã‚¤ãƒ«`submit.rs`ã‚‚æ›¸ã„ã¦ãŠãã¾ã—ãŸã€‚ã‚¹ã‚¯ãƒªãƒ—ãƒˆã®è¨˜äº‹ã¯ä»¥ä¸‹ã‚’å‚ç…§ã€‚ä¸è¦ãªäººã¯ç„¡è¦–ã—ã¦ãã ã•ã„ã€‚

https://zenn.dev/tipstar0125/articles/d423d391a55b6a

ã¾ãŸã€ãƒ“ã‚¸ãƒ¥ã‚¢ãƒ©ã‚¤ã‚¶ã®`vis.rs`ã«é–¢ã—ã¦ã¯ã€ä»¥ä¸‹ã®è¨˜äº‹ã‚’å‚ç…§ã—ã¦ãã ã•ã„ã€‚

https://zenn.dev/tipstar0125/articles/28c3e7981bb91d


# å¤šå¤‰é‡æ­£è¦åˆ†å¸ƒ

æœ¬ã®ä¸­ã§ã¯å¤šå¤‰é‡æ­£è¦åˆ†å¸ƒã«é–¢ã™ã‚‹ã‚³ãƒ¼ãƒ‰ã¯Pythonã®`scipy`ã‚’ä½¿ã£ã¦ã€ã‚µãƒ©ãƒƒã¨æ›¸ã„ã¦ã‚ã‚Šã¾ã™ã€‚ã“ã‚Œã‚’Rustã§ã€ã‹ã¤ã€AtCoderã§ä½¿ç”¨ã§ãã‚‹ã‚¯ãƒ¬ãƒ¼ãƒˆã‚’ä½¿ã£ã¦æ›¸ã“ã†ã¨ã—ãŸã®ã§ã™ãŒã€çµæ§‹è©°ã¾ã‚Šã¾ã—ãŸã€‚çµæœã¨ã—ã¦ã¯ã€ã‚µãƒ³ãƒ—ãƒªãƒ³ã‚°ã¯`nalgebra`ã¨ã„ã†ã‚¯ãƒ¬ãƒ¼ãƒˆã§æ›¸ã‘ãŸã®ã§ã™ãŒã€ç¢ºç‡å¯†åº¦é–¢æ•°ã¯AtCoderã§ã¯ä½¿ç”¨ã§ããªã„`nalgebra-mvn`ã¨ã„ã†ã‚¯ãƒ¬ãƒ¼ãƒˆã‚’ä½¿ç”¨ã—ãªã„ã¨å¤§å¤‰ã§ã—ãŸã€‚AHCã§ä½¿ç”¨ã™ã‚‹ã«ã¯è¨ˆç®—é€Ÿåº¦çš„ã«ã‚‚ã‚ã‚„ã—ã„ã®ã§ã€æœ€çµ‚çš„ã«ã¯ãŠè”µå…¥ã‚Šã¨ã—ã¾ã—ãŸãŒã€`multivariate_normal.rs`ã¨ã„ã†ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚’ä½œæˆã—ãŸã®ã§ã€æ°—ã«ãªã‚‹æ–¹ã¯å‚ç…§ã—ã¦ã¿ã¦ãã ã•ã„ã€‚`plot.rs`ã¯ãã®å‰¯ç”£ç‰©ã§ã€2æ¬¡å…ƒã®æ­£è¦åˆ†å¸ƒã‚’æç”»ã™ã‚‹ç›®çš„ã§ä½œæˆã—ã¾ã—ãŸã€‚

çµå±€ã©ã†ã—ãŸã‹ã¨ã„ã†ã¨ã€æœ¬ã§ã¯å¤šå¤‰é‡æ­£è¦åˆ†å¸ƒã‚’ä½œã‚‹ã¨ãã«ã€å¯¾è§’è¡Œåˆ—ã‚’ä»£å…¥ã—ã¦ã„ãŸã®ã§ã€å„ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿é–“ã«ç›¸é–¢ãªã„ã¨ã¿ãªã›ã°ã€ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã®æ•°ã ã‘1æ¬¡å…ƒã®æ­£è¦åˆ†å¸ƒã‚’ç”¨æ„ã™ã‚‹ã ã‘ã§è‰¯ã„ã¨ã„ã†ã“ã¨ã«ãªã‚Šã¾ã—ãŸã€‚

ã¾ãŸã€ä¸€æ§˜ä¹±æ•°ã‹ã‚‰æ­£è¦åˆ†å¸ƒã«å¾“ã†ä¹±æ•°ã‚’ç”Ÿæˆã™ã‚‹ãŸã‚ã«ã€ãƒœãƒƒã‚¯ã‚¹ãƒŸãƒ¥ãƒ©ãƒ¼ã¨ã„ã†æ‰‹æ³•ã‚’ç”¨ã„ã¦ç”Ÿæˆã—ã¦ã„ã¾ã™ã€‚

:::details normal.rs

```rust:normal.rs
use std::{collections::VecDeque, f64::consts::PI};

use rand::Rng;
use rand_pcg::Pcg64Mcg;

#[derive(Debug)]
pub struct Normal {
    mu: f64,
    std: f64,
    queue: VecDeque<f64>,
}

impl Normal {
    pub fn new(mu: f64, std: f64) -> Self {
        Self {
            mu,
            std,
            queue: VecDeque::new(),
        }
    }
    pub fn sample(&mut self, rng: &mut Pcg64Mcg) -> f64 {
        if self.queue.is_empty() {
            let (x, y) = box_muller(rng, self.mu, self.std);
            self.queue.push_back(x);
            self.queue.push_back(y);
        }
        self.queue.pop_front().unwrap()
    }
    pub fn pdf(&self, x: f64) -> f64 {
        normal_pdf(x, self.mu, self.std)
    }
}

fn box_muller(rng: &mut Pcg64Mcg, mu: f64, std: f64) -> (f64, f64) {
    let u1 = rng.gen::<f64>();
    let u2 = rng.gen::<f64>();

    (
        mu + (-2.0 * u1.ln() * std.powf(2.0)).sqrt() * (2.0 * PI * u2).cos(),
        mu + (-2.0 * u1.ln() * std.powf(2.0)).sqrt() * (2.0 * PI * u2).sin(),
    )
}

fn normal_pdf(x: f64, mu: f64, std: f64) -> f64 {
    let v = (x - mu) / std;
    // æ­£ç¢ºã«ã¯ä»¥ä¸‹ã ãŒã€å°¤åº¦è¨ˆç®—ã«ãŠã„ã¦å®šæ•°ã¯ä¸è¦
    // (-0.5 * v * v).exp() / ((2.0 * PI).sqrt() * std)
    (-0.5 * v * v).exp() / std
}
```

:::

# å•é¡Œè¨­å®š

ä»¥ä¸‹ã®æ¡ä»¶ã«ãŠã‘ã‚‹ãƒ­ãƒœãƒƒãƒˆã®è‡ªå·±ä½ç½®ã‚’æ¨å®šã›ã‚ˆã€‚

- ã‚ã‚‹ä¸€å®šã®é€Ÿåº¦ã€è§’é€Ÿåº¦ã§ç§»å‹•ã™ã‚‹ãƒ­ãƒœãƒƒãƒˆãŒã‚ã‚‹
- ãƒ­ãƒœãƒƒãƒˆã®é€Ÿåº¦ã€è§’é€Ÿåº¦ã¯æ—¢çŸ¥ã§ã‚ã‚‹ãŒã€å¤–ä¹±ã«ã‚ˆã‚‹å½±éŸ¿ã‚’å—ã‘ã‚‹
- ãƒ­ãƒœãƒƒãƒˆã®åˆæœŸå§¿å‹¢ï¼ˆä½ç½®ã‚„å‘ãï¼‰ãŒä¸ãˆã‚‰ã‚Œã‚‹
- ãƒ­ãƒœãƒƒãƒˆã¯ã‚«ãƒ¡ãƒ©ã‚’æœ‰ã—ã¦ãŠã‚Šã€ä½ç½®æƒ…å ±ãŒæ—¢çŸ¥ã®ãƒ©ãƒ³ãƒ‰ãƒãƒ¼ã‚¯ã‚’è¦³æ¸¬ã—ã€è·é›¢ã‚„ãƒ­ãƒœãƒƒãƒˆæ­£é¢ã‚’åŸºæº–ã¨ã—ãŸè§’åº¦ã‚’å–å¾—ã§ãã‚‹
- å–å¾—ã—ãŸè¦³æ¸¬çµæœã«ã¯å¤–ä¹±ã«ã‚ˆã‚‹å½±éŸ¿ã‚’å—ã‘ã‚‹
- ä¸Šè¿°ã®å¤–ä¹±ã¯å®Ÿéš›ã¯æœªçŸ¥ã®ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã ãŒã€å®Ÿé¨“ã«ã‚ˆã‚Šå¾—ã‚‰ã‚ŒãŸæƒ…å ±ã‚’ç”¨ã„ã‚‹ã“ã¨ãŒã§ãã‚‹(AHCã«ãŠã„ã¦ã¯å…¥åŠ›ç”Ÿæˆæ–¹æ³•ã§ä¸ãˆã‚‰ã‚Œã‚‹)

## å…¥åŠ›

```rust: main.rs(æŠœç²‹)
let input = Input {
    time_span: 30.0,   // sec
    time_interval: 0.1, // sec
    height: 10,
    width: 10,
    landmarks: vec![
        Coord { x: -4.0, y: 2.0 },
        Coord { x: 2.0, y: -3.0 },
        Coord { x: 3.0, y: 3.0 },
    ],
    // ãƒ­ãƒœãƒƒãƒˆåˆæœŸå§¿å‹¢
    init_pose: Pose {
        coord: Coord { x: 0.0, y: 0.0 },
        theta: 0.0,
    },
    radius: 0.2,                  // ãƒ­ãƒœãƒƒãƒˆåŠå¾„, m
    nu: 0.2,                      // ãƒ­ãƒœãƒƒãƒˆã®å‰æ–¹æ–¹å‘ã®é€Ÿåº¦, m/s
    omega: 10.0_f64.to_radians(), // ãƒ­ãƒœãƒƒãƒˆã®ä¸­å¿ƒã®è§’é€Ÿåº¦, rad/s
};

// å®Ÿé¨“ã«ã‚ˆã‚Šå¾—ãŸå„ãƒã‚¤ã‚ºã®æ¨™æº–åå·®
let nn_std = 0.19;
let no_std = 0.001;
let on_std = 0.13;
let oo_std = 0.2;
let distance_rate_std = 0.14;
let direction_std = 0.05;
```

## å¤–ä¹±ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ç”¨ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿

æœ¬ã®ä¸­ã§ã¯ã€æ§˜ã€…ãªå¤–ä¹±ãŒè¨˜è¼‰ã•ã‚Œã¦ãŠã‚Šã€ã‚³ãƒ¼ãƒ‰ã«ã‚‚åæ˜ ã—ã¦ã„ã¾ã™ãŒã€ä»Šå›ã¯ä»¥ä¸‹ã«é™å®šã—ã¦ã„ã¾ã™ã€‚
`Agent`æ§‹é€ ä½“ã«ã¯ãŸãã•ã‚“ã®å¤–ä¹±ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ç”¨ã®ãƒ¡ã‚½ãƒƒãƒ‰ã‚’ç”¨æ„ã—ãŸã®ã§ã€é©å®œä½¿ç”¨ã—ã¦éŠã‚“ã§ãã ã•ã„ã€‚

```rust: main.rs(æŠœç²‹)
// å‹•ä½œãƒã‚¤ã‚º(å®Ÿéš›ã¯æœªçŸ¥ã®ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿)
let noise_per_meter = 5.0; // é“ã®ã‚Šã‚ãŸã‚Šã«è¸ã¿ã¤ã‘ã‚‹å°çŸ³ã®æœŸå¾…å€¤
let noise_std = PI / 60.0; // å°çŸ³ã‚’è¸ã‚“ã æ™‚ã«ãšã‚Œã‚‹è§’åº¦ã®ç¢ºç‡å¯†åº¦é–¢æ•°(æ­£è¦åˆ†å¸ƒ)
agent.set_motion_noise(noise_per_meter, noise_std);

// è¦³æ¸¬ãƒã‚¤ã‚º(å®Ÿéš›ã¯æœªçŸ¥ã®ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿)
let distance_noise_rate = 0.1; // å˜ä½è¦³æ¸¬é•·å½“ãŸã‚Šã®è¦³æ¸¬è·é›¢ãƒã‚¤ã‚ºã®æ¨™æº–åå·®
let direction_noise = PI / 90.0; // è¦³æ¸¬è§’åº¦ãƒã‚¤ã‚ºã®æ¨™æº–åå·®
agent.set_camera_noise(distance_noise_rate, direction_noise);
```

# ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ãƒ•ã‚£ãƒ«ã‚¿ã®æµã‚Œ

ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ãƒ•ã‚£ãƒ«ã‚¿ã®æµã‚Œã¯ä»¥ä¸‹ã®é€šã‚Šã§ã™ã€‚
ã“ã‚Œã¯ç§ã®ç†è§£ã‚’å™›ã¿ç •ã„ã¦èª¬æ˜ã—ã¦ãŠã‚Šã€å³å¯†æ€§ã«æ¬ ã‘ã‚‹ã¨æ€ã†ã®ã§ã€è©³ç´°ã¯æœ¬ã‚’ã¿ã¦ãã ã•ã„ã€‚

1. åˆæœŸä½ç½®ãŒä¸ãˆã‚‰ã‚Œã‚‹ã®ã§ã€æœ€åˆã®ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ã‚’åˆæœŸä½ç½®ã«è¨­å®šã€‚
2. ã‚¤ãƒ³ã‚¿ãƒ¼ãƒãƒ«åˆ†æ™‚é–“çµŒé(ãƒ­ãƒœãƒƒãƒˆç§»å‹•)ã€‚
3. ç›´å‰ã®ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ã®ä½ç½®æƒ…å ±ã‹ã‚‰å„ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ã«ã¤ã„ã¦ã€ç§»å‹•é€Ÿåº¦ã«å¾“ã„ç§»å‹•ï¼ˆçŠ¶æ…‹æ–¹ç¨‹å¼ã«ã‚ˆã‚‹é·ç§»ï¼‰ã€‚ã“ã®éš›ã€æ­£è¦åˆ†å¸ƒã«å¾“ã†å¤–ä¹±ã‚’ä»˜ä¸ã€‚
4. ãƒ­ãƒœãƒƒãƒˆã®ã‚«ãƒ¡ãƒ©ã«ã‚ˆã‚Šã€ç¾åœ¨ã®ãƒ©ãƒ³ãƒ‰ãƒãƒ¼ã‚¯ã®ä½ç½®æƒ…å ±å–å¾—ã€‚
5. å„ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ã«ãŠã„ã¦ã€å®Ÿéš›ã«ä½ç½®æƒ…å ±ã‚’å¾—ã‚‰ã‚ŒãŸãƒ©ãƒ³ãƒ‰ãƒãƒ¼ã‚¯ã‚’è¦³æ¸¬ã—ãŸå ´åˆã®å°¤åº¦ã‚’è¨ˆç®—ï¼ˆãƒ™ã‚¤ã‚ºã®å®šç†ï¼‰ã€‚
6. å°¤åº¦ã§é‡ã¿ã¥ã‘ã—ã¦ã€ãƒªã‚µãƒ³ãƒ—ãƒªãƒ³ã‚°ï¼ˆå°¤åº¦ãŒå°ã•ã„ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ã¯ãƒ•ã‚£ãƒ«ã‚¿ãƒªãƒ³ã‚°ã•ã‚Œã‚‹ï¼‰ã€‚
7. æœ€ã‚‚å°¤åº¦ãŒé«˜ã„ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ã‚’è‡ªå·±ä½ç½®ã¨æ¨å®š
8. 2ã«æˆ»ã‚Šç¹°ã‚Šè¿”ã™

é–¢é€£ã‚³ãƒ¼ãƒ‰ã‚’ä»¥ä¸‹ã«æŠœç²‹ã—ã¾ã™ã€‚

:::details ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ãƒ•ã‚£ãƒ«ã‚¿é–¢é€£ã‚³ãƒ¼ãƒ‰æŠœç²‹


```rust: main.rs(æŠœç²‹)
for _ in 0..max_turn {
    let observation = agent.action(&input.landmarks);
    estimator.decision(&observation, &input.landmarks);
}
```

```rust: agent.rs(actionãƒ¡ã‚½ãƒƒãƒ‰)
pub fn action(&mut self, landmarks: &[Coord]) -> Vec<Observation> {
    self.motion.state_transition_with_noise(
        &mut self.rng,
        self.time_interval,
        &mut self.pose,
        self.radius,
        self.nu,
        self.omega,
    );
    self.pose_records.push(self.pose);
    let obs = self.camera.observe(&mut self.rng, self.pose, landmarks);
    self.obs_records.push(obs.clone());
    obs
}
```

```rust: estimator.rs(Estimatoræ§‹é€ ä½“)

#[derive(Debug)]
pub struct Estimator {
    pub rng: Pcg64Mcg,
    pub time_interval: f64,
    pub radius: f64,
    pub nu: f64,
    pub omega: f64,
    pub prev_nu: f64,
    pub prev_omega: f64,
    pub particles: Vec<Particle>,
    pub motion_noise_pdf: MotionNoisePdf,
    pub distance_rate_std: f64,
    pub direction_std: f64,
    pub pose_records: Vec<Vec<Pose>>,
    pub best_weight_records: Vec<usize>,
}

impl Estimator {
    pub fn new(
        time_interval: f64,
        init_pose: Pose,
        radius: f64,
        nu: f64,
        omega: f64,
        particle_num: usize,
        motion_noise_pdf: MotionNoisePdf,
        distance_rate_std: f64,
        direction_std: f64,
    ) -> Self {
        Self {
            rng: Pcg64Mcg::seed_from_u64(0),
            time_interval,
            radius,
            nu,
            omega,
            prev_nu: 0.0,
            prev_omega: 0.0,
            particles: vec![Particle::new(init_pose, 1.0); particle_num],
            motion_noise_pdf,
            distance_rate_std,
            direction_std,
            pose_records: vec![vec![init_pose; particle_num]],
            best_weight_records: vec![0],
        }
    }
    pub fn update_motion(&mut self, prev_nu: f64, prev_omega: f64) {
        let mut poses = vec![];
        for particle in self.particles.iter_mut() {
            let (nn_noise, no_noise, on_noise, oo_noise) =
                self.motion_noise_pdf.sample(&mut self.rng);
            let noised_nu = prev_nu
                + nn_noise * (prev_nu.abs() / self.time_interval).sqrt()
                + no_noise * (prev_omega.abs() / self.time_interval);
            let noised_omega = prev_omega
                + on_noise * (prev_nu.abs() / self.time_interval).sqrt()
                + oo_noise * (prev_omega.abs() / self.time_interval);
            particle.pose =
                state_transition(self.time_interval, particle.pose, noised_nu, noised_omega);
            poses.push(particle.pose.clone());
        }
        self.pose_records.push(poses);
    }
    pub fn updater_observation(&mut self, observation: &Vec<Observation>, landmarks: &[Coord]) {
        for particle in self.particles.iter_mut() {
            for obs in observation.iter() {
                let mark = landmarks[obs.id];
                let obs_particle = observe_landmark(&particle.pose, &mark, obs.id);
                let distance_std = self.distance_rate_std * obs_particle.dist;
                let distance_normal = Normal::new(obs_particle.dist, distance_std);
                let direction_normal = Normal::new(obs_particle.angle, self.direction_std);
                particle.weight *= distance_normal.pdf(obs.dist);
                particle.weight *= direction_normal.pdf(obs.angle);
            }
        }
    }
    // ç³»çµ±ã‚µãƒ³ãƒ—ãƒªãƒ³ã‚°
    pub fn resampling(&mut self) {
        let mut ws = vec![];
        let mut s = 0.0;
        self.particles.iter().for_each(|particle| {
            s += particle.weight;
            ws.push(s);
        });
        if s < 1e-100 {
            ws = ws.iter().map(|x| x + 1e-100).collect();
            s += 1e-100;
        }
        let step = s / self.particles.len() as f64;
        let mut r = self.rng.gen_range(0.0..step);
        let mut pos = 0;
        let mut particle = vec![];
        let mut best_particle_idx = 0;
        let mut best_weight = std::f64::MIN;
        while particle.len() < self.particles.len() {
            if r < ws[pos] {
                if best_weight < self.particles[pos].weight {
                    best_weight = self.particles[pos].weight;
                    best_particle_idx = particle.len();
                }
                self.particles[pos].weight = 1.0;
                particle.push(self.particles[pos]);
                r += step;
            } else {
                pos += 1;
            }
        }
        self.particles = particle;
        self.best_weight_records.push(best_particle_idx);
    }
    pub fn decision(&mut self, observation: &Vec<Observation>, landmarks: &[Coord]) {
        self.update_motion(self.prev_nu, self.prev_omega);
        self.prev_nu = self.nu;
        self.prev_omega = self.omega;
        self.updater_observation(observation, landmarks);
        self.resampling();
    }
}
```
:::

# ãƒ“ã‚¸ãƒ¥ã‚¢ãƒ©ã‚¤ã‚¶

ãƒ“ã‚¸ãƒ¥ã‚¢ãƒ©ã‚¤ã‚¶ã®çµæœã¯ä»¥ä¸‹ã®é€šã‚Šã§ã™ã€‚
ã¾ã ã¾ã æ”¹å–„ã®ä½™åœ°ãŒã‚ã‚‹ã‹ã‚‚ã—ã‚Œã¾ã›ã‚“ãŒã€ãã“ãã“è‡ªå·±ä½ç½®ã‚’æ¨å®šã§ãã¦ã„ã‚‹ã“ã¨ã‚’ç¢ºèªã§ãã¾ã™ã€‚

- èµ¤ä¸¸ï¼šãƒ­ãƒœãƒƒãƒˆ
- é’çŸ¢å°ï¼šãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«
- ç·‘çŸ¢å°ï¼šæœ€å°¤ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«
- é»„ä¸¸ï¼šãƒ©ãƒ³ãƒ‰ãƒãƒ¼ã‚¯

![Document](/images/particle_filter.gif)