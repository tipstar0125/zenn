---
title: "AtCoder　ABC ヒント・考察AC集 【茶】"
emoji: 🏃
type: "tech"
topics: ["AtCoder", "競プロ"]
published: false
---

# ABC285 C - Rotate and Palindrome

https://atcoder.jp/contests/abc286/tasks/abc286_c

:::details ヒント1
:::

:::details 考察AC1
:::

:::details キーワード
:::

# ABC285 D - Money in Hand

https://atcoder.jp/contests/abc286/tasks/abc286_d

:::details ヒント1
:::

:::details 考察AC1
:::

:::details キーワード
:::

# ABC285 D - Change Usernames

https://atcoder.jp/contests/abc285/tasks/abc285_d

:::details ヒント1
グラフで考えて、できない場合の特徴を探そう。
:::

:::details ヒント2
有向グラフとして考えても良いが、制約より無向グラフとして考えても良い。
:::

:::details 考察AC1
1. ユーザ名を変更できない場合は、グラフに閉路があるので、閉路の有無を確認する。
2. グラフとして扱いやすいように文字列を数字に変換する。
3. 無向グラフと考えて、UnionFindで閉路検出する。
4. uniteするときに、2点が同じ根（リーダ）であれば、閉路なので、"No"を出力し、終了する。
5. 最後までuniteできれば、"Yes"を出力する。
:::

:::details 考察AC2
1. ユーザ名を変更できない場合は、グラフに閉路があるので、閉路の有無を確認する。
2. グラフとして扱いやすいように文字列を数字に変換する。
3. 有向グラフと考えて、トポロジカルソートできれば"Yes"、できなければ"No"を出力する。
:::

:::details キーワード
- 閉路
- UnionFind
- トポロジカルソート
:::

# ABC284 D - Happy New Year 2023

https://atcoder.jp/contests/abc284/tasks/abc284_d

:::details ヒント1
素因数分解の計算量は、$O(\sqrt{N})$。今回の場合これだと間に合わないので、もう工夫必要。
制約をよく見よう。$N=p^{2}q$と表せる、というのは重要な制約。
:::

:::details ヒント2
p, qの上限を考える。
:::

:::details 考察AC1
1. $\sqrt[3]{N}$まで試し割りすれば、少なくともともp, qどちらかが見つかる。
2. 2回割り切れたらpで、qはNをpで2回割った値。
3. 1回しか割り切れなかったらqで、pはNをqで割った平方根（浮動小数点誤差に注意）。
:::

:::details キーワード
- 素因数分解
- 試し割り
- 上限
:::

# ABC283 D - Scope

https://atcoder.jp/contests/abc283/tasks/abc283_d

:::details ヒント1
集合を使う。
:::

:::details ヒント2
()の処理はスタックで管理すると見通しが良くなる場合がある。
:::

:::details 考察AC1
1. ボールを入れる箱を集合Xで管理する。
2. 集合のスタックYを用意し、()内に含まれている英小文字を管理する。1文字目が英小文字の場合（例外、外側に括弧があると考える）を考慮して、空集合を予め追加しておく。
3. $S_{i}$が英小文字のときは、Xに英小文字が含まれている場合は、"No"を出力し終了する。そうでない場合は、XとYのlastに英小文字を追加する。
4. $S_{i}$が"("のときは、空集合をYに追加する。
5. $S_{i}$が")"のときは、Yをpopし、その集合をXから除去する。
6. 処理が全て行えれば"Yes"を出力する。
:::

:::details キーワード
- 集合
- スタック
:::

# ABC279 D - Freefall

https://atcoder.jp/contests/abc279/tasks/abc279_d

:::details ヒント1
関数をグラフに図示して、特徴を捉えよう。
:::

:::details ヒント2
凸関数の最大・最小を求めるアルゴリズムについて調べよう。
:::

:::details ヒント3
（別解）最小のとき傾きが0。
:::

:::details 考察AC1
1. 凸関数の最小値を求める問題なので3分探索が使用できる。
2. 誤差を考慮して、探索結果の前後複数を計算をして最小値を出力する。
:::

:::details 考察AC2
1. 凸関数の最小値を求める問題なので、傾きが0のときのx、すなわち$f'(x)=0$を事前計算する。
2. 誤差を考慮して、xの前後複数を計算をして最小値を出力する
:::

:::details キーワード
- 3分探索
- 微分
:::

# ABC278 D - All Assign Point Add

https://atcoder.jp/contests/abc278/tasks/abc278_d

:::details ヒント1
Aの初期値をクエリ2を各indexに行われた状態と考える。
:::

:::details ヒント2
クエリ1で初期化。
:::

:::details ヒント3
初期化の最大計算量は？
:::

:::details 考察AC1
1. 全ての要素に代入する値baseの初期値を0とし、Aを加える値とする。
2. Aに値が加えられたindexを管理する配列added_indexを用意する。最初は全て加えられている。
3. クエリ1のとき、baseに$x_{q}$を代入して、added_indexが空になるまで、indexを取り出して、A[index] = 0として初期化する。
4. クエリ2のとき、Aを更新し、更新したindexをadded_indexに追加する。
5. クエリ3のとき、指定の値にbaseを加えて出力する。
:::

:::details 考察AC2
1. AのindexをキーとしたHashMapを作成する。これを$A_{i}$に加える初期値とする。
2. 全ての要素に代入する値baseの初期値を0とする。
3. クエリ1のとき、baseに$x_{q}$を代入して、HashMapを初期化する。
4. クエリ2のとき、HashMapを更新する。
5. クエリ3のとき、指定の値にbaseを加えて出力する。
:::

:::details キーワード
- 計算量
- HashMap
:::

# ABC277 C - Ladder Takahashi

https://atcoder.jp/contests/abc277/tasks/abc277_c

:::details ヒント1
グラフ
:::

:::details ヒント2
DFS or BFS or UnionFind
:::

:::details ヒント3
$A_{i}, B_{i}$の値が大きいので、工夫しよう。
:::

:::details 考察AC1
1. 隣接リストを配列ではなく、連想配列でつくる。
   ※配列で扱う場合は、$A_{i}, B_{i}$を座標圧縮して、出力の際に元の値に戻す
2. 1から開始して、到達できる（連結している）最大の頂点をDFS or BFSで探索する。
:::

:::details 考察AC2
1. $A_{i}, B_{i}$を座標圧縮する。文字列などを扱える強化版UnionFindを持っている場合は不要。
2. UnionFindで隣接する頂点をuniteする。
3. 1と同じ根（リーダ）をもつ頂点で最大のものを出力する（座標圧縮前に戻すこと）。
:::

:::details キーワード
- グラフ
- DFS
- BFS
- UnionFind
- 座標圧縮
:::

# ABC276 D - Divide by 2 or 3

https://atcoder.jp/contests/abc276/tasks/abc276_d

:::details ヒント1
サンプルは$a_{n}$を全て1にできる例しか示していない。
:::

:::details ヒント2
例えば$a_{n}$を全て2にできる場合に割りすぎないようにしよう。
:::

:::details ヒント3
$a_{n}$の共通の因数が目標の数値
:::

:::details 考察AC1
1. Aの最大公約数を求める。
2. $a_{i}$を最大公約数で割った後、2 or 3で割り切れるまで割り、カウントする。
3. 割り切った結果が1でなければ、"-1"を出力。
4. 割り切った結果、全て1の場合は、カウント数を出力。
:::

:::details キーワード
- 最大公約数
:::

# ABC275 C - Counting Squares

https://atcoder.jp/contests/abc275/tasks/abc275_c

:::details ヒント1
2点を決めたとき、正方形の残り2点は一意に決まる
:::

:::details ヒント2
4点を全探索したときの計算量は？
:::

:::details ヒント3
重複して数えていないか？
:::

:::details 考察AC1
1. 2点を決めたとき、正方形の残りの2点は一意に決まるので、2点を全探索する。
2. 重複で数えてしまうのを避けるために、2点目は、1点目から時計回りで連続する位置におり、かつ、右斜め下向きの辺になるような点とする（真横、真下はどちらかを含み、どちらかを含まないようにする）。
※重複で数えないよう2点目の点の位置を限定しない場合は、重複カウントする回数を最後に割る、または、集合で4点の座標を管理する。
3. 1点目(x1, y1)と2点目(x2, y2)の座標の差分をΔx(=x2-x1), Δy(=y2-y1)とすると、3点目の座標は(x2+Δy, y2-Δx)、4点目の座標は(x2+Δy, y2-Δx)となる。3点目(x3, y3)から4点目(x3-Δx, y3-Δy)を決めても可。
4. 3点目と4点目が領域範囲内で、かつ、"#"であれば、カウントする。
:::

:::details 考察AC2
1. 4点を全探索。点の数をNとすると、N=81。選び方は$O(N^{4})$なので、計算は間に合う。
2. 選んだ4点の中から2点を結んだ線分6本の長さを並べて、昇順に並べる。
3. 小さい方から4本の長さが等しいこと（正方形の辺の長さが等しい）、大きい方から2本の長さが等しいこと（正方形の対角線の長さ等しい）、最も小さい線分d1、最も小さい線分d6の長さの関係が$d6=\sqrt{2}d1$であること（正方形の辺と対角線の関係）、を確認し、カウントする。3つ目の判定に関しては、整数の範囲内で判定できるように両辺を2乗して計算する。
:::

:::details キーワード
- 正方形
- 全探索
- 数え方の工夫
:::

# ABC275 D - Yet Another Recursive Function

https://atcoder.jp/contests/abc275/tasks/abc275_d

:::details ヒント1
計算した結果をメモして、再利用する。
:::

:::details ヒント2
$N=10^{18}$なので、配列でメモすることはできない。
:::

:::details 考察AC1
- 再帰関数を用いる。
- 計算した結果をHashMapでメモする。
- 計算済みならHashMapから結果を取得する。
:::


:::details キーワード
- メモ化再帰
- HashMap(連想配列、辞書)
:::