---
title: "thunderæœ¬ã‚’Rustã§æ›¸ã„ã¦ã¿ãŸ(Greedyã¾ã§)"
emoji: ðŸƒ
type: "tech"
topics: ["rust", "AtCoder", "ç«¶ãƒ—ãƒ­"]
published: true
---

2023å¹´2æœˆ18æ—¥ã«ã€Œã‚²ãƒ¼ãƒ ã§å­¦ã¶æŽ¢ç´¢ã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ å®Ÿè·µå…¥é–€ï½žæœ¨æŽ¢ç´¢ã¨ãƒ¡ã‚¿ãƒ’ãƒ¥ãƒ¼ãƒªã‚¹ãƒ†ã‚£ã‚¯ã‚¹ã€ï¼ˆthunderæœ¬ï¼‰ãŒç™ºå£²ã•ã‚Œã¾ã—ãŸã€‚
ç§ã¯ã¾ã AtCoderã§ã¯ã€ABC, ARCã—ã‹å‚åŠ ã—ãŸã“ã¨ãŒã‚ã‚Šã¾ã›ã‚“ãŒã€ä»Šå¾ŒAtCoderã®AHCã«å‚åŠ ã—ã¦ã¿ãŸãå‹‰å¼·ã™ã‚‹ã“ã¨ã«ã—ã¾ã—ãŸã€‚å†…å®¹ã¯C++ã§æ›¸ã‹ã‚Œã¦ã„ã¾ã™ã€‚C++ã¯èª­ã‚ã‚‹ã®ã§ã™ãŒã€æ›¸ã„ãŸã“ã¨ãŒãªã„ã®ã§ã€å†…å®¹ã‚’ç†è§£ã—ãªãŒã‚‰Rustã§æ›¸ã„ã¦ã¿ã¾ã—ãŸã€‚è©³ç´°ã«é–¢ã—ã¦ã¯ã€æœ¬ã‚’è²·ã£ã¦é ‚ã‘ã‚Œã°ã¨æ€ã„ã¾ã™ã®ã§ã€ã‚³ãƒ¼ãƒ‰ã ã‘ã‚’å…±æœ‰ã—ã¾ã™ã€‚

![altãƒ†ã‚­ã‚¹ãƒˆ](http://image.gihyo.co.jp/assets/images/cover/2023/9784297133603.jpg)

Rustã§ã¯UnionFindä»¥å¤–ã§ãªã‹ãªã‹æ§‹é€ ä½“ã‚’ä½¿ã£ã¦ã€ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆæŒ‡å‘ã§æ›¸ãã“ã¨ãŒãªã„ã®ã§ã€è‰²ã€…è©¦è¡ŒéŒ¯èª¤ã—ãªãŒã‚‰æ›¸ã„ã¦ã„ã¾ã™ã€‚ä»¥ä¸‹ã®ã‚³ãƒ¼ãƒ‰ãŒæœ€é©ãªã‚³ãƒ¼ãƒ‰ã«ãªã£ã¦ã„ã‚‹ã‹ã¯å¾®å¦™ãªã®ã§ã€éµœå‘‘ã¿ã«ã›ãšã€é©å®œã‚«ã‚¹ã‚¿ãƒžã‚¤ã‚ºã—ã¦é ‚ã‘ã‚Œã°ã¨æ€ã„ã¾ã™ã€‚ä»¥ä¸‹æ°—ã«ãªã£ã¦ã„ã‚‹ç‚¹ã‚’ã¾ã¨ã‚ã¦ãŠãã¾ã™ã€‚

1. åž‹å®šç¾©ã‚’`isize`ã«ã™ã¹ãã‹ã€`usize`ã«ã™ã¹ãã‹ã€è¿·ã„ã¾ã—ãŸã€‚ã€‚ã€‚`as`ã§ã‚­ãƒ£ã‚¹ãƒˆã—ã¾ãã‚Šã§ã™ãŒã€Rustã®å ´åˆä»•æ–¹ãªã„ã®ã‹ãªã€‚é…åˆ—ã®indexæŒ‡å®šã¯`usize`ã§ãªã„ã¨ã„ã‘ãªã„ã—ã€‚ã€‚ã€‚
2. `advance`é–¢æ•°å†…ã®`point`ã¯ã€æœ¬ã«ãªã‚‰ã£ã¦ç”Ÿãƒã‚¤ãƒ³ã‚¿ã‚’ä½¿ç”¨ã—ã€`unsafe`ã—ã¦ã„ã¾ã™ã€‚é•å’Œæ„ŸãŒã‚ã‚‹å ´åˆã€ãƒã‚¤ãƒ³ã‚¿ã‚’ä½¿ç”¨ã—ãªã„å†—é•·ãªæ›¸ãæ–¹ã§ã‚‚è‰¯ã„ã‹ãªã¨æ€ã£ã¦ã„ã¾ã™ã€‚
3. `greedyAction`é–¢æ•°ã®ä¸­ã§ã€`state`ã‚’ãƒ‡ã‚£ãƒ¼ãƒ—ã‚³ãƒ”ãƒ¼ã—ã¦ã€æ¬¡ã®æ‰‹ã®ãƒ™ã‚¹ãƒˆã‚¢ã‚¯ã‚·ãƒ§ãƒ³ã‚’æ±ºã‚ã¦ã„ã¾ã™ã€‚ä»Šå›žã®å ´åˆ`state`ã®æƒ…å ±ãŒã‹ãªã‚Šå°‘ãªã„ã§ã™ãŒã€å¤šã„å ´åˆã¯ã€å¾®å¦™ãªã®ã‹ãªã€ã¨æ€ã£ãŸã‚Šã€‚ã€‚ã€‚å®Ÿéš›ã«`advance`ã—ãªã„ã§ã€`pre_advance`ã¿ãŸã„ãªé–¢æ•°ã‚’ä½œã£ã¦ã€ã‚¢ã‚¯ã‚·ãƒ§ãƒ³ã¯ã›ãšã«ã€æ¬¡ã®æ‰‹ã§å–ã‚Œã‚‹ã‚¹ã‚³ã‚¢ã ã‘ã‚’å–å¾—ã—ãŸæ–¹ãŒè‰¯ã•ãã†ï¼Ÿï¼Ÿ

ä½¿ã„æ–¹ï¼šä¸€éƒ¨ã‚³ãƒ¡ãƒ³ãƒˆã‚¢ã‚¦ãƒˆã—ã¦ã„ã‚‹ç®‡æ‰€ãŒã‚ã‚‹ã®ã§ã€`randomAction` or `greedyAction`ã‚’é¸ã‚“ã ã‚Šã€è¿·è·¯ã®çŠ¶æ…‹ã‚’ä¹±æ•°ã§æŒ‡å®šã™ã‚‹ã‹ã©ã†ã‹ã‚’é¸ã‚“ã ã‚Šã§ãã¾ã™ã€‚

```rust
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(unused_imports)]
#![allow(unused_macros)]
#![allow(clippy::needless_range_loop)]
#![allow(clippy::comparison_chain)]
#![allow(clippy::nonminimal_bool)]
#![allow(clippy::neg_multiply)]
#![allow(dead_code)]
use rand::Rng;
type ScoreType = isize;
const H: usize = 3;
const W: usize = 4;
const END_TURN: usize = 4;
const INF: ScoreType = 1e9 as isize;

#[derive(Debug, Clone)]
struct Coord {
    x_: isize,
    y_: isize,
}
impl Coord {
    fn new() -> Self {
        Coord { x_: 0, y_: 0 }
    }
}

#[derive(Debug, Clone)]
struct MazeState {
    points_: Vec<Vec<usize>>,
    turn_: usize,
    character_: Coord,
    game_score_: usize,
    evaluated_score_: ScoreType,
}

impl MazeState {
    const dx: [isize; 4] = [1, -1, 0, 0];
    const dy: [isize; 4] = [0, 0, 1, -1];
    fn new(seed: Option<u64>) -> Self {
        let mut rng: rand::rngs::StdRng =
            rand::SeedableRng::seed_from_u64(rand::thread_rng().gen());
        if let Some(s) = seed {
            rng = rand::SeedableRng::seed_from_u64(s)
        }

        let mut character_ = Coord::new();
        character_.x_ = rng.gen_range(0, W) as isize;
        character_.y_ = rng.gen_range(0, H) as isize;
        let mut points_ = vec![vec![0; W]; H];
        for y in 0..H {
            for x in 0..W {
                if x as isize == character_.x_ && y as isize == character_.y_ {
                    continue;
                }
                points_[y][x] = rng.gen_range(0, 10);
            }
        }
        MazeState {
            points_,
            turn_: 0,
            character_,
            game_score_: 0,
            evaluated_score_: 0,
        }
    }
    fn isDone(&self) -> bool {
        self.turn_ == END_TURN
    }
    fn advance(&mut self, action: usize) {
        self.character_.x_ += Self::dx[action];
        self.character_.y_ += Self::dy[action];
        let point = &mut self.points_[self.character_.y_ as usize][self.character_.x_ as usize]
            as *mut usize;
        unsafe {
            if *point > 0 {
                self.game_score_ += *point;
                *point = 0;
            }
        }
        self.turn_ += 1;
    }
    fn legalActions(&self) -> Vec<usize> {
        let mut actions = vec![];
        for action in 0..4 {
            let ty = self.character_.y_ + Self::dy[action];
            let tx = self.character_.x_ + Self::dx[action];
            if 0 <= ty && ty < H as isize && 0 <= tx && tx < W as isize {
                actions.push(action);
            }
        }
        actions
    }
    fn toString(&self) {
        println!("turn: {}", self.turn_);
        println!("score: {}", self.game_score_);
        for y in 0..H {
            for x in 0..W {
                if self.character_.y_ == y as isize && self.character_.x_ == x as isize {
                    print!("@");
                } else if self.points_[y][x] > 0 {
                    print!("{}", self.points_[y][x]);
                } else {
                    print!(".");
                }
            }
            println!();
        }
    }
    fn evaluateScore(&mut self) {
        self.evaluated_score_ = self.game_score_ as isize;
    }
}

fn randomAction(state: &MazeState) -> usize {
    let legal_actions = state.legalActions();
    let mut rng: rand::rngs::StdRng = rand::SeedableRng::seed_from_u64(0);
    legal_actions[rng.gen_range(0, legal_actions.len())]
}

fn greedyAction(state: &MazeState) -> usize {
    let legal_actions = state.legalActions();
    let mut best_score = -INF;
    let mut best_action = -1_isize;
    for &action in &legal_actions {
        let mut now_state = state.clone();
        now_state.advance(action);
        now_state.evaluateScore();
        if now_state.evaluated_score_ > best_score {
            best_score = now_state.evaluated_score_;
            best_action = action as isize;
        }
    }
    best_action as usize
}

fn playGame(seed: Option<u64>) -> usize {
    let mut state = MazeState::new(seed);
    state.toString();
    while !state.isDone() {
        // state.advance(randomAction(&state));
        state.advance(greedyAction(&state));
        state.toString();
    }
    state.game_score_
}

fn testApiScore(game_number: usize) {
    let mut score_mean = 0.0;
    for _ in 0..game_number {
        score_mean += playGame(None) as f64;
        // score_mean += playGame(Some(12)) as f64;
    }
    score_mean /= game_number as f64;
    println!("Score: {:.2}", score_mean);
}

fn main() {
    testApiScore(100);
}

```

```
[dependencies]
rand = "0.6"
```
